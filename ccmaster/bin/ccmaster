#!/usr/bin/env python3
"""
CCMaster - Claude Code Session Manager

A tool to manage and monitor Claude Code sessions with automatic continuation capabilities.

Version: 2.0.0
"""

__version__ = "2.0.0"

import argparse
import json
import os
import sys
import subprocess
import threading
import time
import queue
import select
import tty
import termios
from datetime import datetime
from pathlib import Path
import shlex

# ANSI color codes
class Colors:
    GREEN = '\033[92m'
    RED = '\033[91m'
    YELLOW = '\033[93m'
    BLUE = '\033[94m'
    PURPLE = '\033[95m'
    RESET = '\033[0m'
    BOLD = '\033[1m'

class CCMaster:
    def __init__(self):
        self.config_dir = Path.home() / '.ccmaster'
        self.config_file = self.config_dir / 'config.json'
        self.sessions_file = self.config_dir / 'sessions.json'
        self.logs_dir = self.config_dir / 'logs'
        self.status_dir = self.config_dir / 'status'
        
        # Create necessary directories
        self.config_dir.mkdir(exist_ok=True)
        self.logs_dir.mkdir(exist_ok=True)
        self.status_dir.mkdir(exist_ok=True)
        
        # Load or create config
        self.config = self.load_config()
        
        # Load sessions
        self.sessions = self.load_sessions()
        
        # Message queue for thread-safe printing
        self.message_queue = queue.Queue()
        self.should_stop = False
        
        # Current status for the session - now a dict for multi-agent
        self.current_status = {}
        
        # Multi-agent support
        self.active_sessions = {}  # session_id -> session data
        self.session_threads = {}  # session_id -> threads
        self.watch_modes = {}  # session_id -> bool
        self.auto_continue_counts = {}  # session_id -> count
        self.max_turns = {}  # session_id -> max_turns
        self.has_seen_first_prompt = {}  # session_id -> bool
        
        # Thread-safe printing
        self.print_lock = threading.Lock()
    
    def load_config(self):
        """Load or create default configuration"""
        if self.config_file.exists():
            with open(self.config_file, 'r') as f:
                return json.load(f)
        else:
            default_config = {
                'claude_code_command': 'claude',
                'monitor_interval': 0.5
            }
            with open(self.config_file, 'w') as f:
                json.dump(default_config, f, indent=2)
            return default_config
    
    def load_sessions(self):
        """Load existing sessions"""
        if self.sessions_file.exists():
            with open(self.sessions_file, 'r') as f:
                return json.load(f)
        return {}
    
    def save_sessions(self):
        """Save sessions to file"""
        with open(self.sessions_file, 'w') as f:
            json.dump(self.sessions, f, indent=2)
    
    def create_session(self, working_dir):
        """Create a new session"""
        # Add microseconds to ensure unique IDs when creating multiple sessions quickly
        session_id = datetime.now().strftime('%Y%m%d_%H%M%S_%f')[:21]  # Trim to reasonable length
        session = {
            'id': session_id,
            'started_at': datetime.now().isoformat(),
            'working_dir': working_dir,
            'status': 'starting',
            'pid': None,
            'last_activity': datetime.now().isoformat()
        }
        self.sessions[session_id] = session
        self.save_sessions()
        return session_id
    
    def log_event(self, session_id, event_type, message, display=True):
        """Log an event for a session"""
        log_file = self.logs_dir / f"{session_id}.log"
        timestamp = datetime.now()
        
        log_entry = {
            'timestamp': timestamp.isoformat(),
            'type': event_type,
            'message': message
        }
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
        
        if display and not self.should_stop:
            # For multi-agent compatibility, include session_id
            self.message_queue.put((session_id, 'LOG', timestamp, event_type, message))
    
    def create_hooks_config(self, session_id):
        """Create per-session hooks configuration"""
        claude_dir = Path.home() / '.claude'
        claude_dir.mkdir(exist_ok=True)
        
        # Settings file paths
        settings_file = claude_dir / 'settings.json'
        backup_file = claude_dir / 'settings.json.backup'
        
        # Backup existing settings if they exist
        if settings_file.exists():
            with open(settings_file, 'r') as f:
                existing_settings = json.load(f)
            with open(backup_file, 'w') as f:
                json.dump(existing_settings, f, indent=2)
        else:
            existing_settings = {}
        
        # Get the hooks directory path (resolve symlinks)
        real_path = Path(__file__).resolve()
        hooks_dir = real_path.parent.parent / 'hooks'
        
        # Create per-session hooks configuration with correct format
        hooks_config = {
            'hooks': {
                'PreToolUse': [{
                    'matcher': '.*',
                    'hooks': [{
                        'type': 'command',
                        'command': f'python3 {str(hooks_dir / "pre_tool_use.py")} {session_id}'
                    }]
                }],
                'UserPromptSubmit': [{
                    'hooks': [{
                        'type': 'command',
                        'command': f'python3 {str(hooks_dir / "user_prompt_submit.py")} {session_id}'
                    }]
                }],
                'Stop': [{
                    'hooks': [{
                        'type': 'command',
                        'command': f'python3 {str(hooks_dir / "stop_hook.py")} {session_id}'
                    }]
                }]
            }
        }
        
        # Merge with existing settings
        if 'hooks' in existing_settings:
            # Store original hooks for restoration
            original_hooks = existing_settings.get('hooks', {})
            settings_file = Path.home() / '.claude' / 'settings.json'
            backup_file = self.config_dir / f'original_hooks_{session_id}.json'
            with open(backup_file, 'w') as f:
                json.dump(original_hooks, f, indent=2)
        
        existing_settings.update(hooks_config)
        
        # Write updated settings
        with open(settings_file, 'w') as f:
            json.dump(existing_settings, f, indent=2)
        
        return settings_file, backup_file
    
    def restore_hooks_config(self, session_id):
        """Restore original hooks configuration"""
        settings_file = Path.home() / '.claude' / 'settings.json'
        backup_file = Path.home() / '.claude' / 'settings.json.backup'
        
        # Restore from backup if it exists
        if backup_file.exists():
            with open(backup_file, 'r') as f:
                original_settings = json.load(f)
            with open(settings_file, 'w') as f:
                json.dump(original_settings, f, indent=2)
            backup_file.unlink()  # Remove backup
        else:
            # If no backup, just remove hooks
            if settings_file.exists():
                with open(settings_file, 'r') as f:
                    settings = json.load(f)
                if 'hooks' in settings:
                    del settings['hooks']
                with open(settings_file, 'w') as f:
                    json.dump(settings, f, indent=2)
    
    def format_status_line(self, status):
        """Format status line with appropriate color"""
        if status == 'idle':
            return f"{Colors.RED}● Idle{Colors.RESET}"
        elif status == 'processing':
            return f"{Colors.YELLOW}● Processing{Colors.RESET}"
        elif status == 'working':
            return f"{Colors.GREEN}● Working{Colors.RESET}"
        elif status == 'thinking':
            return f"{Colors.PURPLE}● Thinking{Colors.RESET}"
        else:
            return f"● {status}"
    
    def find_claude_process(self, session_id, start_time=None):
        """Find Claude process by command name"""
        time.sleep(2)  # Give Claude time to start
        
        # Try multiple methods to find the process
        methods_tried = []
        
        # Method 1: Using pgrep with full command
        try:
            result = subprocess.run(['pgrep', '-f', self.config['claude_code_command']], 
                                  capture_output=True, text=True)
            if result.returncode == 0 and result.stdout.strip():
                pids = result.stdout.strip().split('\n')
                methods_tried.append(f"pgrep found PIDs: {pids}")
                
                # Filter out our own process and ccmaster
                our_pid = os.getpid()
                for pid_str in pids:
                    try:
                        pid = int(pid_str)
                        if pid != our_pid:
                            # Verify it's actually Claude and not ccmaster
                            ps_result = subprocess.run(['ps', '-p', str(pid), '-o', 'command='],
                                                     capture_output=True, text=True)
                            if ps_result.returncode == 0:
                                command = ps_result.stdout.strip()
                                if 'claude' in command and 'ccmaster' not in command and 'python' not in command:
                                    self.log_event(session_id, 'DEBUG', f'Found Claude PID: {pid} via pgrep', display=False)
                                    return pid
                    except ValueError:
                        continue
        except Exception as e:
            methods_tried.append(f"pgrep error: {e}")
        
        # Method 2: Using ps aux with filtering
        try:
            result = subprocess.run(['ps', 'aux'], capture_output=True, text=True)
            if result.returncode == 0:
                our_pid = os.getpid()
                for line in result.stdout.strip().split('\n'):
                    if self.config['claude_code_command'] in line and 'ccmaster' not in line and 'python' not in line:
                        parts = line.split()
                        if len(parts) > 1:
                            try:
                                pid = int(parts[1])
                                if pid != our_pid:
                                    self.log_event(session_id, 'DEBUG', f'Found Claude PID: {pid} via ps aux', display=False)
                                    return pid
                            except ValueError:
                                continue
                methods_tried.append("ps aux found no matching processes")
        except Exception as e:
            methods_tried.append(f"ps aux error: {e}")
        
        self.log_event(session_id, 'WARNING', f'Could not find Claude process. Methods tried: {"; ".join(methods_tried)}', display=False)
        return None
    
    def monitor_session(self, session_id):
        """Monitor if the Claude session is still running"""
        # Wait for process to start and find its PID
        pid = self.find_claude_process(session_id)
        if pid:
            self.sessions[session_id]['pid'] = pid
            self.save_sessions()
            self.log_event(session_id, 'PROCESS', f'Monitoring Claude process (PID: {pid})', display=False)
        else:
            self.log_event(session_id, 'WARNING', 'Could not find Claude process PID, continuing anyway', display=False)
        
        consecutive_failures = 0
        max_failures = 3  # Allow 3 consecutive failures before declaring session ended
        
        while not self.should_stop:
            try:
                # Check if process is still running
                if pid:
                    try:
                        # Check if PID still exists
                        os.kill(pid, 0)
                        
                        # Double-check with pgrep to ensure Claude is really still running
                        result = subprocess.run(
                            ['pgrep', '-f', 'claude'],
                            capture_output=True, text=True
                        )
                        claude_still_running = False
                        if result.returncode == 0 and result.stdout.strip():
                            # Verify our specific PID is in the list
                            pids = result.stdout.strip().split('\n')
                            for pid_str in pids:
                                try:
                                    if int(pid_str) == pid:
                                        # Final check: make sure it's actually Claude
                                        ps_result = subprocess.run(['ps', '-p', str(pid), '-o', 'command='],
                                                                 capture_output=True, text=True)
                                        if ps_result.returncode == 0 and 'claude' in ps_result.stdout:
                                            claude_still_running = True
                                            break
                                except ValueError:
                                    continue
                        
                        if not claude_still_running:
                            consecutive_failures += 1
                            self.log_event(session_id, 'DEBUG', f'Claude process check failed ({consecutive_failures}/{max_failures})', display=False)
                            
                            if consecutive_failures >= max_failures:
                                self.log_event(session_id, 'SESSION_END', 'Claude session ended (process not found)')
                                break
                        else:
                            consecutive_failures = 0
                            self.log_event(session_id, 'DEBUG', f'Claude process {pid} still running', display=False)
                    except (OSError, ProcessLookupError):
                        consecutive_failures += 1
                        self.log_event(session_id, 'DEBUG', f'Process {pid} not found ({consecutive_failures}/{max_failures})', display=False)
                        
                        if consecutive_failures >= max_failures:
                            self.log_event(session_id, 'SESSION_END', 'Claude session ended (PID not found)')
                            break
                
                time.sleep(2)  # Check every 2 seconds
                
            except Exception as e:
                self.log_event(session_id, 'ERROR', f'Monitoring error: {str(e)}')
                break
    
    def is_claude_running(self, session_id):
        """Check if the Claude process for this specific session is running"""
        # First check if we have a PID stored for this session
        if session_id in self.sessions and 'claude_pid' in self.sessions[session_id]:
            pid = self.sessions[session_id]['claude_pid']
            try:
                # Check if specific PID is still running
                os.kill(pid, 0)  # Signal 0 checks if process exists
                # Double-check it's actually a Claude process
                result = subprocess.run(['ps', '-p', str(pid), '-o', 'command='], 
                                      capture_output=True, text=True)
                if result.returncode == 0 and self.config['claude_code_command'] in result.stdout:
                    return True
            except (OSError, ProcessLookupError):
                # Process doesn't exist
                pass
        
        # If we don't have a PID or it's not running, return False
        return False
    
    def find_claude_pid_for_session(self, session_id, start_time, max_attempts=10):
        """Find the PID of the Claude process we just launched"""
        for attempt in range(max_attempts):
            time.sleep(1)
            try:
                # Get all Claude processes started after our launch time
                result = subprocess.run(['ps', 'aux'], capture_output=True, text=True)
                if result.returncode == 0:
                    current_time = time.time()
                    for line in result.stdout.split('\n'):
                        if self.config['claude_code_command'] in line and 'ccmaster' not in line:
                            parts = line.split()
                            if len(parts) > 1:
                                pid = int(parts[1])
                                # Get process start time to ensure it's our process
                                stat_result = subprocess.run(['ps', '-p', str(pid), '-o', 'lstart='],
                                                           capture_output=True, text=True)
                                if stat_result.returncode == 0:
                                    # Check if this process started around our launch time
                                    # (within 5 seconds of our launch)
                                    if current_time - start_time < 5:
                                        return pid
            except Exception as e:
                self.log_event(session_id, 'DEBUG', f'Error finding Claude PID: {e}', display=False)
        
        return None
    
    def is_terminal_window_open(self, session_id):
        """Check if the Terminal window for this session is still open"""
        if session_id not in self.sessions or 'terminal_window_id' not in self.sessions[session_id]:
            return True  # If we don't have window info, assume it's open
        
        window_id = self.sessions[session_id]['terminal_window_id']
        
        # AppleScript to check if window exists
        check_script = f'''
        tell application "Terminal"
            try
                set w to window id {window_id}
                return "exists"
            on error
                return "not_found"
            end try
        end tell
        '''
        
        try:
            result = subprocess.run(['osascript', '-e', check_script], 
                                  capture_output=True, text=True, timeout=2)
            return result.returncode == 0 and result.stdout.strip() == "exists"
        except:
            return True  # On error, assume window is open
    
    def simple_monitor_session(self, session_id, launch_time):
        """Simple session monitoring that checks if the specific Claude process is still running"""
        consecutive_failures = 0
        max_failures = 5  # Allow 5 consecutive failures (10 seconds) before declaring dead
        
        # First, try to find the PID of the Claude process we launched
        claude_pid = self.find_claude_pid_for_session(session_id, launch_time)
        if claude_pid:
            self.sessions[session_id]['claude_pid'] = claude_pid
            self.save_sessions()
            self.log_event(session_id, 'DEBUG', f'Found Claude process PID: {claude_pid}', display=False)
            self.log_event(session_id, 'PROCESS', f'Tracking Claude process (PID: {claude_pid})', display=True)
        else:
            self.log_event(session_id, 'WARNING', 'Could not find Claude PID, monitoring may be less accurate', display=False)
        
        while True:
            try:
                # First check if the terminal window is still open
                if not self.is_terminal_window_open(session_id):
                    self.log_event(session_id, 'SESSION_END', 'Terminal window closed', display=True)
                    self.sessions[session_id]['status'] = 'ended'
                    self.sessions[session_id]['ended_at'] = datetime.now().isoformat()
                    self.save_sessions()
                    self.log_event(session_id, 'SESSION_END', 'Claude session ended (terminal window closed)')
                    break
                
                # Then check if Claude process is running
                if self.is_claude_running(session_id):
                    consecutive_failures = 0
                    self.log_event(session_id, 'DEBUG', 'Claude process detected', display=False)
                else:
                    consecutive_failures += 1
                    self.log_event(session_id, 'DEBUG', f'Claude not detected, count: {consecutive_failures}/{max_failures}', display=False)
                    
                    if consecutive_failures >= max_failures:
                        print(f"\n[{datetime.now().strftime('%H:%M:%S')}] ☠ Claude session appears to have ended")
                        self.sessions[session_id]['status'] = 'ended'
                        self.sessions[session_id]['ended_at'] = datetime.now().isoformat()
                        self.save_sessions()
                        self.log_event(session_id, 'SESSION_END', 'Claude session ended (process not found)')
                        break
                
                time.sleep(2)  # Check every 2 seconds
                
            except Exception as e:
                self.log_event(session_id, 'ERROR', f'Monitoring error: {str(e)}')
                break
    
    def send_continue_to_claude(self, session_id):
        """Send 'continue' to the specific Claude session only"""
        # Only use stored window and tab info - no fallback to avoid confusion
        if session_id not in self.sessions:
            print(f"[{datetime.now().strftime('%H:%M:%S')}] {Colors.YELLOW}▲ Session not found for auto-continue{Colors.RESET}")
            return False
            
        window_id = self.sessions[session_id].get('terminal_window_id')
        tab_index = self.sessions[session_id].get('terminal_tab_index')
        
        if not window_id or not tab_index:
            print(f"[{datetime.now().strftime('%H:%M:%S')}] {Colors.YELLOW}▲ No terminal window info stored for this session{Colors.RESET}")
            return False
        
        # Use specific window and find Claude tab
        specific_script = f'''
        tell application "Terminal"
            activate
            try
                -- Check if window still exists
                set targetWindow to window id {window_id}
                
                -- Find the tab running Claude in this window
                set foundTab to false
                repeat with t in tabs of targetWindow
                    try
                        if (processes of t) contains "claude" then
                            -- Found Claude tab, make it active and send continue
                            set foundTab to true
                            set frontmost of targetWindow to true
                            set selected of t to true
                            delay 0.3
                            
                            -- Type continue and press return
                            tell application "System Events"
                                tell process "Terminal"
                                    keystroke "continue"
                                    delay 0.1
                                    keystroke return
                                end tell
                            end tell
                            return "success"
                        end if
                    end try
                end repeat
                
                if not foundTab then
                    return "no_claude_in_window"
                end if
            on error
                return "window_not_found"
            end try
        end tell
        '''
        
        try:
            result = subprocess.run(['osascript', '-e', specific_script], 
                                  capture_output=True, text=True, timeout=5)
            
            if result.returncode == 0:
                output = result.stdout.strip()
                if output == "success":
                    return True
                elif output == "no_claude_in_window":
                    # Check if we're in multi-agent mode
                    if session_id in self.active_sessions and len(self.active_sessions) >= 2:
                        idx = self.active_sessions[session_id]['index']
                        self.thread_safe_print(f"[{idx}][{datetime.now().strftime('%H:%M:%S')}] {Colors.YELLOW}▲ Claude is no longer running in the tracked window{Colors.RESET}")
                    else:
                        self.thread_safe_print(f"[{datetime.now().strftime('%H:%M:%S')}] {Colors.YELLOW}▲ Claude is no longer running in the tracked window{Colors.RESET}")
                    return False
                elif output == "window_not_found":
                    if session_id in self.active_sessions and len(self.active_sessions) >= 2:
                        idx = self.active_sessions[session_id]['index']
                        self.thread_safe_print(f"[{idx}][{datetime.now().strftime('%H:%M:%S')}] {Colors.YELLOW}▲ The tracked terminal window no longer exists{Colors.RESET}")
                    else:
                        self.thread_safe_print(f"[{datetime.now().strftime('%H:%M:%S')}] {Colors.YELLOW}▲ The tracked terminal window no longer exists{Colors.RESET}")
                    return False
            
            if session_id in self.active_sessions and len(self.active_sessions) >= 2:
                idx = self.active_sessions[session_id]['index']
                self.thread_safe_print(f"[{idx}][{datetime.now().strftime('%H:%M:%S')}] {Colors.RED}✖ Failed to send 'continue' command{Colors.RESET}")
            else:
                self.thread_safe_print(f"[{datetime.now().strftime('%H:%M:%S')}] {Colors.RED}✖ Failed to send 'continue' command{Colors.RESET}")
            return False
            
        except Exception as e:
            if session_id in self.active_sessions and len(self.active_sessions) >= 2:
                idx = self.active_sessions[session_id]['index']
                self.thread_safe_print(f"[{idx}][{datetime.now().strftime('%H:%M:%S')}] {Colors.RED}✖ Auto-continue error: {str(e)}{Colors.RESET}")
            else:
                self.thread_safe_print(f"[{datetime.now().strftime('%H:%M:%S')}] {Colors.RED}✖ Auto-continue error: {str(e)}{Colors.RESET}")
            return False
    
    def start_session_and_monitor(self, working_dir=None, watch_mode=False, max_turns=None):
        """Start a new Claude session and monitor it"""
        # Always use current directory if not specified
        if working_dir is None:
            working_dir = os.getcwd()
        else:
            working_dir = os.path.abspath(working_dir)
        
        # Create session
        session_id = self.create_session(working_dir)
        
        # Print session info
        print(f"⟐ Starting Claude session in {working_dir}")
        print(f"◆ Session ID: {session_id}")
        if watch_mode:
            if max_turns:
                print(f"⊙ {Colors.GREEN}Watch mode: ON - Will auto-continue after idle (max {max_turns} turns){Colors.RESET}")
            else:
                print(f"⊙ {Colors.GREEN}Watch mode: ON - Will auto-continue after idle{Colors.RESET}")
        else:
            print(f"○ Watch mode: OFF - Press [w] to toggle")
        print()
        
        self.log_event(session_id, 'SESSION_START', f'Starting in {working_dir}', display=False)
        
        # Create per-session hooks configuration
        settings_file, backup_file = self.create_hooks_config(session_id)
        self.log_event(session_id, 'HOOKS', f'Created hooks configuration for session', display=False)
        
        # Prepare Claude Code command
        claude_cmd = self.config['claude_code_command'] + ' --dangerously-skip-permissions'
        
        # AppleScript to open Terminal and start Claude, returning window and tab info
        applescript = f'''
        tell application "Terminal"
            activate
            set newTab to do script "cd {working_dir} && {claude_cmd}"
            set windowId to id of window 1
            -- Get the tab index
            set tabIndex to 1
            repeat with t in tabs of window 1
                if t is newTab then
                    exit repeat
                end if
                set tabIndex to tabIndex + 1
            end repeat
            return "" & windowId & "," & tabIndex
        end tell
        '''
        
        # Execute AppleScript and record launch time
        launch_time = time.time()
        result = subprocess.run(['osascript', '-e', applescript], 
                                capture_output=True, text=True)
        
        if result.returncode == 0:
            # Parse window and tab info
            try:
                window_tab_info = result.stdout.strip()
                if ',' in window_tab_info:
                    window_id, tab_index = window_tab_info.split(',')
                    self.sessions[session_id]['terminal_window_id'] = int(window_id)
                    self.sessions[session_id]['terminal_tab_index'] = int(tab_index)
                    self.log_event(session_id, 'LAUNCH', f'Launched Claude in Terminal (Window: {window_id}, Tab: {tab_index})', display=True)
                else:
                    self.log_event(session_id, 'LAUNCH', 'Launched Claude in Terminal', display=True)
            except Exception as e:
                self.log_event(session_id, 'LAUNCH', f'Launched Claude in Terminal (parse error: {e})', display=True)
        else:
            self.log_event(session_id, 'ERROR', f'Failed to launch Claude: {result.stderr}', display=True)
        
        # Update session status
        self.sessions[session_id]['status'] = 'running'
        self.save_sessions()
        
        # Start simple monitoring thread that checks if Claude is running
        monitor_thread = threading.Thread(
            target=self.simple_monitor_session,
            args=(session_id, launch_time),
            daemon=True
        )
        monitor_thread.start()
        
        # Start status monitoring thread
        status_thread = threading.Thread(
            target=self.monitor_status,
            args=(session_id,),
            daemon=True
        )
        status_thread.start()
        
        # Initial status
        current_status_display = self.format_status_line('idle')
        has_seen_first_prompt = False
        auto_continue_pending = False
        continue_countdown = 0
        auto_continue_count = 0
        
        # Initialize current_status for this session
        if isinstance(self.current_status, dict):
            self.current_status[session_id] = 'idle'
        
        # Set up terminal for keyboard input
        old_settings = termios.tcgetattr(sys.stdin)
        
        try:
            # Configure terminal for non-blocking input
            tty.setraw(sys.stdin.fileno())
            
            # Main monitoring loop
            while True:
                # Check for keyboard input
                key = self.check_keyboard_input()
                if key == 'q':
                    self.safe_print(f"\n[{datetime.now().strftime('%H:%M:%S')}] ■ Stopping session monitor...", old_settings)
                    self.should_stop = True
                    break
                elif key == 'w':
                    was_at_max_turns = max_turns and auto_continue_count >= max_turns
                    watch_mode = not watch_mode
                    timestamp = datetime.now()
                    time_str = timestamp.strftime('%H:%M:%S')
                    if watch_mode:
                        # Reset auto-continue count when toggling watch mode on after hitting max
                        if was_at_max_turns:
                            auto_continue_count = 0
                            self.safe_print(f"[{time_str}] {Colors.GREEN}↻ Auto-continue count reset{Colors.RESET}", old_settings)
                        
                        if max_turns:
                            remaining = max_turns - auto_continue_count
                            self.safe_print(f"[{time_str}] {Colors.GREEN}⊙ Watch mode: ON - Will auto-continue after idle ({remaining} turns left){Colors.RESET}", old_settings)
                        else:
                            self.safe_print(f"[{time_str}] {Colors.GREEN}⊙ Watch mode: ON - Will auto-continue after idle{Colors.RESET}", old_settings)
                        
                        # If we're currently idle and re-enabling after max turns, immediately continue
                        current_session_status = self.current_status[session_id] if isinstance(self.current_status, dict) else self.current_status
                        if was_at_max_turns and current_session_status == 'idle':
                            # Send continue immediately
                            if self.send_continue_to_claude(session_id):
                                auto_continue_count += 1
                                if max_turns:
                                    self.safe_print(f"[{time_str}] {Colors.GREEN}▶ Auto-continue ({auto_continue_count}/{max_turns}){Colors.RESET}", old_settings)
                                else:
                                    self.safe_print(f"[{time_str}] {Colors.GREEN}▶ Auto-continue{Colors.RESET}", old_settings)
                    else:
                        self.safe_print(f"[{time_str}] ○ Watch mode: OFF", old_settings)
                        # Cancel any pending auto-continue
                        auto_continue_pending = False
                        continue_countdown = 0
                
                # Process messages from queue
                try:
                    while True:
                        # Get 5-tuple message (session_id, msg_type, timestamp, event_type, message)
                        session_id_from_msg, msg_type, timestamp, event_type, message = self.message_queue.get_nowait()
                        time_str = timestamp.strftime('%H:%M:%S')
                        
                        if msg_type == 'STATUS':
                            # Handle status updates
                            if 'Working' in message:
                                status_display = self.format_status_line('working')
                                if 'tool:' in message:
                                    tool = message.split('tool:')[1].strip()
                                    self.safe_print(f"[{time_str}] {status_display}", old_settings)
                                    self.safe_print(f"[{time_str}] → Using {tool}", old_settings)
                                else:
                                    self.safe_print(f"[{time_str}] {status_display}", old_settings)
                            elif 'Processing' in message:
                                status_display = self.format_status_line('processing')
                                self.safe_print(f"[{time_str}] {status_display}", old_settings)
                            elif 'Thinking' in message:
                                status_display = self.format_status_line('thinking')
                                self.safe_print(f"[{time_str}] {status_display}", old_settings)
                            elif 'Idle' in message:
                                status_display = self.format_status_line('idle')
                                self.safe_print(f"[{time_str}] {status_display}", old_settings)
                                # In watch mode, auto-continue after first prompt
                                if watch_mode and has_seen_first_prompt:
                                    # Check if we've reached max turns
                                    if max_turns is None or auto_continue_count < max_turns:
                                        auto_continue_pending = True
                                        continue_countdown = 2  # 2 seconds to ensure Claude is really idle
                                    else:
                                        self.safe_print(f"[{time_str}] {Colors.YELLOW}■ Max auto-continue turns ({max_turns}) reached - Watch mode disabled{Colors.RESET}", old_settings)
                                        self.safe_print(f"[{time_str}] → Press [w] to re-enable and continue", old_settings)
                                        watch_mode = False
                            current_status_display = status_display
                            
                        elif event_type == 'USER':
                            # Format user prompt
                            prompt_preview = message[:50] + '...' if len(message) > 50 else message
                            prompt_preview = prompt_preview.replace('\n', ' ')
                            self.safe_print(f"[{time_str}] ▶ User: \"{prompt_preview}\"", old_settings)
                            has_seen_first_prompt = True
                            # Cancel any pending auto-continue when user types
                            auto_continue_pending = False
                            continue_countdown = 0
                            
                        elif event_type == 'SESSION_END':
                            self.safe_print(f"\n[{time_str}] ■ {message}", old_settings)
                            self.should_stop = True
                            
                        elif event_type == 'LAUNCH':
                            self.safe_print(f"[{time_str}] ⟐ {message}", old_settings)
                            
                        elif event_type == 'PROCESS':
                            self.safe_print(f"[{time_str}] ◎ {message}", old_settings)
                            
                        elif event_type == 'WARNING':
                            self.safe_print(f"[{time_str}] {Colors.YELLOW}▲ {message}{Colors.RESET}", old_settings)
                            
                        elif event_type == 'ERROR':
                            self.safe_print(f"[{time_str}] {Colors.RED}✖ {message}{Colors.RESET}", old_settings)
                            
                except queue.Empty:
                    pass
                
                # Handle auto-continue countdown
                if auto_continue_pending and continue_countdown > 0:
                    time.sleep(1)  # Count down 1 second
                    continue_countdown -= 1
                    
                    if continue_countdown == 0:
                        # Send continue command
                        if self.send_continue_to_claude(session_id):
                            auto_continue_pending = False
                            auto_continue_count += 1
                            # Log the successful auto-continue
                            timestamp = datetime.now()
                            time_str = timestamp.strftime('%H:%M:%S')
                            if max_turns:
                                self.safe_print(f"[{time_str}] {Colors.GREEN}▶ Auto-continue ({auto_continue_count}/{max_turns}){Colors.RESET}", old_settings)
                            else:
                                self.safe_print(f"[{time_str}] {Colors.GREEN}▶ Auto-continue{Colors.RESET}", old_settings)
                            self.log_event(session_id, 'AUTO_CONTINUE', f'Sent auto-continue #{auto_continue_count}', display=False)
                        else:
                            auto_continue_pending = False
                            self.safe_print(f"[{time_str}] {Colors.YELLOW}▲ Failed to send auto-continue{Colors.RESET}", old_settings)
                
                # Break if session should stop
                if self.should_stop:
                    break
                
                # Small sleep to prevent busy-waiting
                time.sleep(0.1)
                
        except KeyboardInterrupt:
            print(f"\n[{datetime.now().strftime('%H:%M:%S')}] ■ Session interrupted by user")
        finally:
            # Restore terminal settings
            termios.tcsetattr(sys.stdin, termios.TCSADRAIN, old_settings)
            print("\n■ Session ended.")
            
            # Update session status
            if session_id in self.sessions:
                self.sessions[session_id]['status'] = 'ended'
                self.sessions[session_id]['ended_at'] = datetime.now().isoformat()
                self.save_sessions()
            
            # Restore original hooks configuration
            self.restore_hooks_config(session_id)
    
    def check_keyboard_input(self):
        """Check for keyboard input without blocking"""
        if sys.stdin in select.select([sys.stdin], [], [], 0)[0]:
            return sys.stdin.read(1)
        return None
    
    def safe_print(self, message, old_settings):
        """Safely print in raw terminal mode"""
        # Temporarily restore normal mode for printing
        termios.tcsetattr(sys.stdin, termios.TCSADRAIN, old_settings)
        print(message)
        sys.stdout.flush()
        # Return to raw mode
        tty.setraw(sys.stdin.fileno())
    
    def thread_safe_print(self, message):
        """Thread-safe printing that handles raw mode automatically"""
        with self.print_lock:
            try:
                # Try to get current terminal settings
                old_settings = termios.tcgetattr(sys.stdin)
                # Temporarily switch to normal mode
                termios.tcsetattr(sys.stdin, termios.TCSADRAIN, old_settings)
                print(message)
                sys.stdout.flush()
                # Return to raw mode
                tty.setraw(sys.stdin.fileno())
            except:
                # If not in raw mode, just print normally
                print(message)
                sys.stdout.flush()
    
    def monitor_status(self, session_id):
        """Monitor the status file for updates"""
        status_file = self.status_dir / f"{session_id}.json"
        
        # Create an empty status file
        with open(status_file, 'w') as f:
            json.dump({'state': 'idle', 'session_id': session_id}, f)
        
        last_update = None
        
        while not self.should_stop:
            try:
                # Check if status file exists and has been updated
                if status_file.exists():
                    with open(status_file, 'r') as f:
                        try:
                            status_data = json.load(f)
                            current_update = status_data.get('timestamp')
                            
                            if current_update != last_update:
                                last_update = current_update
                                state = status_data.get('state', 'idle')
                                # For multi-agent compatibility, use dictionary
                                if isinstance(self.current_status, dict):
                                    self.current_status[session_id] = state
                                else:
                                    self.current_status = state
                                
                                # Format and queue the status message
                                if state == 'working':
                                    tool = status_data.get('last_tool', '')
                                    message = f"Working - tool: {tool}"
                                elif state == 'processing':
                                    message = "Processing"
                                elif state == 'thinking':
                                    message = "Thinking"
                                else:
                                    message = "Idle"
                                
                                # For multi-agent compatibility, always include session_id
                                self.message_queue.put((session_id, 'STATUS', datetime.now(), 'STATUS', message))
                                
                                # Check for user prompts
                                if state == 'processing' and 'prompt' in status_data:
                                    prompt = status_data['prompt']
                                    # For multi-agent compatibility
                                    self.message_queue.put((session_id, 'USER', datetime.now(), 'USER', prompt))
                                    
                                    # Log the prompt to the prompts file
                                    prompt_log_file = self.logs_dir / f"{session_id}_prompts.log"
                                    with open(prompt_log_file, 'a') as pf:
                                        log_entry = {
                                            'timestamp': datetime.now().isoformat(),
                                            'prompt': prompt
                                        }
                                        pf.write(json.dumps(log_entry) + '\n')
                        except json.JSONDecodeError:
                            pass
                
                time.sleep(self.config['monitor_interval'])
                
            except Exception as e:
                if not self.should_stop:
                    self.log_event(session_id, 'ERROR', f'Status monitoring error: {str(e)}')
    
    def list_sessions(self):
        """List all sessions"""
        if not self.sessions:
            print("No sessions found.")
            return
        
        print(f"{Colors.BOLD}Sessions:{Colors.RESET}")
        print(f"{'ID':<20} {'Status':<10} {'Started':<20} {'Directory'}")
        print("-" * 80)
        
        for session_id, session in sorted(self.sessions.items(), reverse=True):
            started = datetime.fromisoformat(session['started_at']).strftime('%Y-%m-%d %H:%M:%S')
            status = session['status']
            if status == 'running':
                status_colored = f"{Colors.GREEN}{status}{Colors.RESET}"
            elif status == 'ended':
                status_colored = f"{Colors.RED}{status}{Colors.RESET}"
            else:
                status_colored = status
            
            print(f"{session_id:<20} {status_colored:<19} {started:<20} {session['working_dir']}")
    
    def view_logs(self, session_id):
        """View logs for a specific session"""
        log_file = self.logs_dir / f"{session_id}.log"
        if not log_file.exists():
            print(f"No logs found for session {session_id}")
            return
        
        print(f"{Colors.BOLD}Logs for session {session_id}:{Colors.RESET}")
        print("-" * 80)
        
        with open(log_file, 'r') as f:
            for line in f:
                try:
                    entry = json.loads(line)
                    timestamp = datetime.fromisoformat(entry['timestamp']).strftime('%H:%M:%S')
                    event_type = entry['type']
                    message = entry['message']
                    
                    # Color code by event type
                    if event_type == 'ERROR':
                        type_colored = f"{Colors.RED}{event_type}{Colors.RESET}"
                    elif event_type == 'SESSION_START':
                        type_colored = f"{Colors.GREEN}{event_type}{Colors.RESET}"
                    elif event_type == 'SESSION_END':
                        type_colored = f"{Colors.YELLOW}{event_type}{Colors.RESET}"
                    else:
                        type_colored = event_type
                    
                    print(f"[{timestamp}] {type_colored:<20} {message}")
                except json.JSONDecodeError:
                    print(line.strip())
    
    def view_prompts(self, session_id):
        """View user prompts for a specific session"""
        prompt_file = self.logs_dir / f"{session_id}_prompts.log"
        if not prompt_file.exists():
            print(f"No prompts found for session {session_id}")
            return
        
        print(f"{Colors.BOLD}User prompts for session {session_id}:{Colors.RESET}")
        print("-" * 80)
        
        with open(prompt_file, 'r') as f:
            for line in f:
                try:
                    entry = json.loads(line)
                    timestamp = datetime.fromisoformat(entry['timestamp']).strftime('%Y-%m-%d %H:%M:%S')
                    prompt = entry['prompt']
                    
                    print(f"{Colors.BLUE}[{timestamp}]{Colors.RESET}")
                    print(f"{prompt}")
                    print("-" * 40)
                except json.JSONDecodeError:
                    print(line.strip())

    def start_multi_session_and_monitor(self, working_dir=None, watch_mode=False, max_turns=None, num_instances=2):
        """Start multiple Claude sessions and monitor them concurrently"""
        # Always use current directory if not specified
        if working_dir is None:
            working_dir = os.getcwd()
        else:
            working_dir = os.path.abspath(working_dir)
        
        print(f"⟐ Starting {num_instances} Claude sessions in {working_dir}")
        if watch_mode:
            if max_turns:
                print(f"👁️  {Colors.GREEN}Watch mode: ON - Will auto-continue after idle (max {max_turns} turns per session){Colors.RESET}")
            else:
                print(f"⊙ {Colors.GREEN}Watch mode: ON - Will auto-continue after idle{Colors.RESET}")
        else:
            print(f"👀 Watch mode: OFF - Press [w] to toggle for all sessions")
        print()
        
        # Create all sessions
        session_ids = []
        for i in range(num_instances):
            session_id = self.create_session(working_dir)
            session_ids.append(session_id)
            self.active_sessions[session_id] = {
                'index': i + 1,
                'working_dir': working_dir,
                'status': 'starting'
            }
            self.current_status[session_id] = 'idle'
            self.watch_modes[session_id] = watch_mode
            self.auto_continue_counts[session_id] = 0
            self.max_turns[session_id] = max_turns
            self.has_seen_first_prompt[session_id] = False
            
            print(f"[{i+1}] ◆ Session ID: {session_id}")
            self.log_event(session_id, 'SESSION_START', f'Starting session {i+1} of {num_instances} in {working_dir}', display=False)
        
        print()
        
        # Launch all sessions with slight delay between each
        for i, session_id in enumerate(session_ids):
            # Create per-session hooks configuration
            settings_file, backup_file = self.create_hooks_config(session_id)
            self.log_event(session_id, 'HOOKS', f'Created hooks configuration for session', display=False)
            
            # Prepare Claude Code command
            claude_cmd = self.config['claude_code_command'] + ' --dangerously-skip-permissions'
            
            # AppleScript to open Terminal and start Claude
            applescript = f'''
            tell application "Terminal"
                activate
                set newTab to do script "cd {working_dir} && {claude_cmd}"
                set windowId to id of window 1
                set tabIndex to 1
                repeat with t in tabs of window 1
                    if t is newTab then
                        exit repeat
                    end if
                    set tabIndex to tabIndex + 1
                end repeat
                return "" & windowId & "," & tabIndex
            end tell
            '''
            
            # Execute AppleScript
            launch_time = time.time()
            result = subprocess.run(['osascript', '-e', applescript], 
                                    capture_output=True, text=True)
            
            if result.returncode == 0:
                # Parse window and tab info
                try:
                    window_tab_info = result.stdout.strip()
                    if ',' in window_tab_info:
                        window_id, tab_index = window_tab_info.split(',')
                        self.sessions[session_id]['terminal_window_id'] = int(window_id)
                        self.sessions[session_id]['terminal_tab_index'] = int(tab_index)
                        self.active_sessions[session_id]['terminal_window_id'] = int(window_id)
                        self.active_sessions[session_id]['terminal_tab_index'] = int(tab_index)
                        self.log_event(session_id, 'LAUNCH', f'Launched Claude in Terminal (Window: {window_id}, Tab: {tab_index})', display=True)
                except Exception as e:
                    self.log_event(session_id, 'LAUNCH', 'Launched Claude in Terminal', display=True)
            else:
                self.log_event(session_id, 'ERROR', f'Failed to launch Claude: {result.stderr}', display=True)
            
            # Update session status
            self.sessions[session_id]['status'] = 'running'
            self.active_sessions[session_id]['status'] = 'running'
            self.save_sessions()
            
            # Start monitoring threads for this session
            monitor_thread = threading.Thread(
                target=self.simple_monitor_session,
                args=(session_id, launch_time),
                daemon=True
            )
            monitor_thread.start()
            self.session_threads[session_id] = {'monitor': monitor_thread}
            
            status_thread = threading.Thread(
                target=self.monitor_status,
                args=(session_id,),
                daemon=True
            )
            status_thread.start()
            self.session_threads[session_id]['status'] = status_thread
            
            # Small delay between launching sessions
            if i < num_instances - 1:
                time.sleep(1)
        
        print("\n✻ All sessions launched. Monitoring...")
        print("Press [q] to quit, [w] to toggle watch mode for all sessions\n")
        
        # Message printer thread for multi-agent
        printer_thread = threading.Thread(
            target=self.multi_session_message_printer,
            daemon=True
        )
        printer_thread.start()
        
        # Set up terminal for keyboard input
        old_settings = termios.tcgetattr(sys.stdin)
        
        try:
            # Configure terminal for non-blocking input
            tty.setraw(sys.stdin.fileno())
            
            # Main monitoring loop
            while not self.should_stop:
                # Check for keyboard input
                key = self.check_keyboard_input()
                if key == 'q':
                    self.safe_print(f"\n[{datetime.now().strftime('%H:%M:%S')}] ■ Stopping all session monitors...", old_settings)
                    self.should_stop = True
                    break
                elif key == 'w':
                    # Toggle watch mode for all sessions
                    new_watch_mode = not any(self.watch_modes.values())
                    for sid in self.active_sessions:
                        self.watch_modes[sid] = new_watch_mode
                        if new_watch_mode and self.max_turns[sid] and self.auto_continue_counts[sid] >= self.max_turns[sid]:
                            self.auto_continue_counts[sid] = 0
                    
                    time_str = datetime.now().strftime('%H:%M:%S')
                    if new_watch_mode:
                        self.safe_print(f"\n[{time_str}] {Colors.GREEN}👁️  Watch mode: ON for all sessions{Colors.RESET}", old_settings)
                    else:
                        self.safe_print(f"\n[{time_str}] 👀 Watch mode: OFF for all sessions", old_settings)
                
                # Check session statuses and handle auto-continue
                for session_id in list(self.active_sessions.keys()):
                    if session_id not in self.current_status:
                        continue
                        
                    # Check if terminal window is still open
                    if not self.is_terminal_window_open(session_id):
                        idx = self.active_sessions[session_id]['index']
                        self.message_queue.put((session_id, 'SESSION_END', datetime.now(), 'SESSION_END', f'Terminal window closed'))
                        del self.active_sessions[session_id]
                        continue
                    
                    # Handle auto-continue for idle sessions (only after first prompt)
                    if (self.watch_modes.get(session_id, False) and 
                        self.current_status.get(session_id) == 'idle' and
                        self.has_seen_first_prompt.get(session_id, False) and
                        session_id in self.active_sessions):
                        
                        max_t = self.max_turns.get(session_id)
                        count = self.auto_continue_counts.get(session_id, 0)
                        
                        if max_t is None or count < max_t:
                            # Send continue to this specific session
                            if self.send_continue_to_claude(session_id):
                                self.auto_continue_counts[session_id] = count + 1
                                idx = self.active_sessions[session_id]['index']
                                self.message_queue.put((session_id, 'AUTO_CONTINUE', datetime.now(), 'AUTO_CONTINUE', 
                                                      f'Auto-continue ({count + 1}/{max_t if max_t else "∞"})'))
                
                # Small sleep to prevent busy-waiting
                time.sleep(2)
                
        except KeyboardInterrupt:
            print(f"\n[{datetime.now().strftime('%H:%M:%S')}] 🛑 Sessions interrupted by user")
        finally:
            # Restore terminal settings
            termios.tcsetattr(sys.stdin, termios.TCSADRAIN, old_settings)
            print("\n🛑 All sessions ended.")
            
            # Update session statuses
            for session_id in session_ids:
                if session_id in self.sessions:
                    self.sessions[session_id]['status'] = 'ended'
                    self.sessions[session_id]['ended_at'] = datetime.now().isoformat()
                self.save_sessions()
                
                # Restore original hooks configuration
                self.restore_hooks_config(session_id)
    
    def multi_session_message_printer(self):
        """Print messages for multiple concurrent sessions"""
        
        # Get the terminal settings to restore after each print
        import termios
        import tty
        try:
            old_settings = termios.tcgetattr(sys.stdin)
        except:
            old_settings = None
            
        while not self.should_stop:
            try:
                session_id, msg_type, timestamp, event_type, message = self.message_queue.get(timeout=0.1)
                
                if session_id not in self.active_sessions:
                    continue
                    
                idx = self.active_sessions[session_id]['index']
                time_str = timestamp.strftime('%H:%M:%S')
                prefix = f"[{idx}]"
                
                # Use lock to ensure thread-safe printing
                with self.print_lock:
                    # Format message based on type
                    if msg_type == 'STATUS':
                        # Extract status from message
                        if 'Working' in message:
                            status = 'working'
                            tool = message.split('tool:')[1].strip() if 'tool:' in message else None
                        elif 'Processing' in message:
                            status = 'processing'
                            tool = None
                        elif 'Thinking' in message:
                            status = 'thinking'
                            tool = None
                        else:
                            status = 'idle'
                            tool = None
                        
                        self.current_status[session_id] = status
                        
                        # Format status line - clean output without \r
                        status_line = self.format_status_line(status)
                        
                        # Temporarily switch out of raw mode for clean printing
                        if old_settings:
                            termios.tcsetattr(sys.stdin, termios.TCSADRAIN, old_settings)
                        print(f"{prefix}[{time_str}] {status_line}")
                        if tool:
                            print(f"{prefix}[{time_str}] → Using {tool}")
                        sys.stdout.flush()
                        if old_settings:
                            tty.setraw(sys.stdin.fileno())
                            
                    elif event_type == 'USER':
                        prompt_preview = message[:50] + '...' if len(message) > 50 else message
                        prompt_preview = prompt_preview.replace('\n', ' ')
                        # Temporarily switch out of raw mode
                        if old_settings:
                            termios.tcsetattr(sys.stdin, termios.TCSADRAIN, old_settings)
                        print(f"{prefix}[{time_str}] ▶ User: \"{prompt_preview}\"")
                        sys.stdout.flush()
                        if old_settings:
                            tty.setraw(sys.stdin.fileno())
                        # Mark that this session has seen its first prompt
                        self.has_seen_first_prompt[session_id] = True
                        
                    else:
                        # For all other message types, use same pattern
                        if old_settings:
                            termios.tcsetattr(sys.stdin, termios.TCSADRAIN, old_settings)
                            
                        if event_type == 'AUTO_CONTINUE':
                            print(f"{prefix}[{time_str}] {Colors.GREEN}▶ {message}{Colors.RESET}")
                        elif event_type == 'SESSION_END':
                            print(f"{prefix}[{time_str}] {Colors.RED}☠ {message}{Colors.RESET}")
                        elif event_type == 'PROCESS':
                            print(f"{prefix}[{time_str}] ◎ {message}")
                        elif event_type == 'LAUNCH':
                            print(f"{prefix}[{time_str}] ⟐ {message}")
                        elif event_type == 'WARNING':
                            print(f"{prefix}[{time_str}] {Colors.YELLOW}▲ {message}{Colors.RESET}")
                        elif event_type == 'ERROR':
                            print(f"{prefix}[{time_str}] {Colors.RED}✖ {message}{Colors.RESET}")
                        else:
                            # Generic log message
                            print(f"{prefix}[{time_str}] {message}")
                            
                        sys.stdout.flush()
                        if old_settings:
                            tty.setraw(sys.stdin.fileno())
                
            except queue.Empty:
                continue
            except Exception as e:
                if not self.should_stop:
                    with self.print_lock:
                        print(f"\nError in multi-session printer: {e}")

def main():
    parser = argparse.ArgumentParser(description='CCMaster - Claude Code Session Manager')
    
    subparsers = parser.add_subparsers(dest='command', help='Commands')
    
    # Start command (default)
    start_parser = subparsers.add_parser('start', help='Start a new Claude session')
    start_parser.add_argument('-d', '--dir', help='Working directory (defaults to current directory)')
    
    # Watch mode command
    watch_parser = subparsers.add_parser('watch', help='Start in watch mode (auto-continue)')
    watch_parser.add_argument('-d', '--dir', help='Working directory (defaults to current directory)')
    watch_parser.add_argument('--maxturn', type=int, help='Maximum number of auto-continue turns')
    watch_parser.add_argument('--instances', type=int, default=1, help='Number of Claude sessions to manage (default: 1)')
    
    # List command
    list_parser = subparsers.add_parser('list', help='List all sessions')
    
    # Logs command
    logs_parser = subparsers.add_parser('logs', help='View logs for a session')
    logs_parser.add_argument('session_id', help='Session ID')
    
    # Prompts command
    prompts_parser = subparsers.add_parser('prompts', help='View user prompts for a session')
    prompts_parser.add_argument('session_id', help='Session ID')
    
    # Version command
    version_parser = subparsers.add_parser('version', help='Show CCMaster version')
    
    args = parser.parse_args()
    
    cc = CCMaster()
    
    # Default to 'start' if no command specified
    if args.command is None:
        args.command = 'start'
        args.dir = None
    
    if args.command == 'start':
        cc.start_session_and_monitor(args.dir if hasattr(args, 'dir') else None)
    elif args.command == 'watch':
        if args.instances > 1:
            cc.start_multi_session_and_monitor(args.dir, watch_mode=True, max_turns=args.maxturn, num_instances=args.instances)
        else:
            cc.start_session_and_monitor(args.dir, watch_mode=True, max_turns=args.maxturn)
    elif args.command == 'list':
        cc.list_sessions()
    elif args.command == 'logs':
        cc.view_logs(args.session_id)
    elif args.command == 'prompts':
        cc.view_prompts(args.session_id)
    elif args.command == 'version':
        print(f"CCMaster version {__version__}")
        print(f"⟐ Claude Code Session Manager")
        print(f"◆ https://github.com/yourusername/ccmaster")

if __name__ == '__main__':
    main()