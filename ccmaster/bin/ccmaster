#!/usr/bin/env python3
"""
CCMaster - Claude Code Session Manager

A tool to manage and monitor Claude Code sessions with automatic continuation capabilities.

Version: 2.0.0
"""

__version__ = "2.0.0"

import argparse
import json
import os
import sys
import subprocess
import threading
import time
import queue
import select
import tty
import termios
from datetime import datetime
from pathlib import Path
import shlex
import logging

# Import MCP module
# Handle both symlinked and direct execution
script_path = os.path.abspath(__file__)
if os.path.islink(script_path):
    # Follow the symlink to get the real path
    script_path = os.path.realpath(script_path)

# Get the ccmaster root directory (2 levels up from bin/ccmaster)
ccmaster_root = os.path.dirname(os.path.dirname(os.path.dirname(script_path)))
sys.path.insert(0, ccmaster_root)

try:
    from mcp.server import MCPServer
except ImportError:
    # MCP module warning will be handled by CCMaster instance
    MCPServer = None

# ANSI color codes
class Colors:
    GREEN = '\033[92m'
    RED = '\033[91m'
    YELLOW = '\033[93m'
    BLUE = '\033[94m'
    PURPLE = '\033[95m'
    ORANGE = '\033[38;5;208m'  # Orange color
    RESET = '\033[0m'
    BOLD = '\033[1m'

class CCMaster:
    def __init__(self):
        self.config_dir = Path.home() / '.ccmaster'
        self.config_file = self.config_dir / 'config.json'
        self.sessions_file = self.config_dir / 'sessions.json'
        self.logs_dir = self.config_dir / 'logs'
        self.status_dir = self.config_dir / 'status'
        
        # Create necessary directories
        self.config_dir.mkdir(exist_ok=True)
        self.logs_dir.mkdir(exist_ok=True)
        self.status_dir.mkdir(exist_ok=True)
        
        # Load or create config
        self.config = self.load_config()
        
        # Load sessions
        self.sessions = self.load_sessions()
        
        # Message queue for thread-safe printing
        self.message_queue = queue.Queue()
        self.should_stop = False
        
        # Current status for the session - now a dict for multi-agent
        self.current_status = {}
        
        # Multi-agent support
        self.active_sessions = {}  # session_id -> session data
        self.session_threads = {}  # session_id -> threads
        self.watch_modes = {}  # session_id -> bool
        self.auto_continue_counts = {}  # session_id -> count
        self.max_turns = {}  # session_id -> max_turns
        self.has_seen_first_prompt = {}  # session_id -> bool
        
        # Thread-safe printing
        self.print_lock = threading.Lock()
        
        # MCP Server
        self.mcp_server = None
        self.mcp_enabled = self.config.get('mcp', {}).get('enabled', True)
        self.mcp_port = None  # Will be dynamically allocated
        self.mcp_host = self.config.get('mcp', {}).get('host', 'localhost')
        self.mcp_base_port = self.config.get('mcp', {}).get('port', 8181)
        
        # Setup logging - redirect to file only to avoid console spam
        self.logger = logging.getLogger('CCMaster')
        self.logger.setLevel(logging.INFO)
        self.logger.handlers = []  # Clear any existing handlers
        
        # Add file handler only
        log_file = self.logs_dir / 'ccmaster.log'
        file_handler = logging.FileHandler(log_file)
        file_handler.setFormatter(logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s'))
        self.logger.addHandler(file_handler)
        self.logger.propagate = False  # Don't propagate to root logger
        
        # MCP port tracking
        self.mcp_port_file = self.config_dir / 'mcp_port.json'
    
    def load_config(self):
        """Load or create default configuration"""
        if self.config_file.exists():
            with open(self.config_file, 'r') as f:
                return json.load(f)
        else:
            default_config = {
                'claude_code_command': 'claude',
                'monitor_interval': 0.5,
                'mcp': {
                    'enabled': True,
                    'host': 'localhost',
                    'port': 8181,
                    'port_range': [8181, 8181],
                    'ensure_mcp_add': True
                }
            }
            with open(self.config_file, 'w') as f:
                json.dump(default_config, f, indent=2)
            return default_config
    
    def load_sessions(self):
        """Load existing sessions"""
        if self.sessions_file.exists():
            with open(self.sessions_file, 'r') as f:
                return json.load(f)
        return {}
    
    def save_sessions(self):
        """Save sessions to file"""
        with open(self.sessions_file, 'w') as f:
            json.dump(self.sessions, f, indent=2)
    
    def find_available_port(self):
        """Find an available port starting from the configured port"""
        import socket
        
        # Start with the configured port
        base_port = self.config.get('mcp', {}).get('port', 8181)
        max_attempts = 10  # Try up to 10 ports
        
        for offset in range(max_attempts):
            port = base_port + offset
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                try:
                    s.bind((self.mcp_host, port))
                    s.close()
                    if port != base_port:
                        self.cli_log(f"Port {base_port} was busy, using {port} instead", log_type='info')
                    return port
                except OSError:
                    continue
        
        return None
    
    def save_mcp_port(self, port):
        """Save the current MCP port for future sessions"""
        try:
            port_data = {'last_port': port, 'timestamp': time.time()}
            with open(self.mcp_port_file, 'w') as f:
                json.dump(port_data, f)
        except Exception as e:
            self.logger.warning(f"Failed to save MCP port: {e}")
    
    def init_mcp_server(self):
        """Initialize MCP server with static port"""
        if not self.mcp_enabled:
            return
            
        # Check if MCP module is available
        if MCPServer is None:
            self.logger.warning("MCP module not available")
            self.cli_log("Warning: MCP module not found. MCP features will be disabled.", log_type='warning')
            self.cli_log(f"  Looked in: {os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))}", log_type='info')
            self.mcp_enabled = False
            return
            
        # Check if requests module is available (required for stdio_server.py)
        try:
            import requests
        except ImportError:
            self.logger.error("requests module not found - required for MCP")
            self.cli_log("MCP requires the 'requests' module. Install with: pip install requests", log_type='warning')
            self.mcp_enabled = False
            return
            
        # Check if port is available
        self.mcp_port = self.find_available_port()
        
        if not self.mcp_port:
            base_port = self.config.get('mcp', {}).get('port', 8181)
            self.logger.error(f"No available ports found starting from {base_port}")
            self.cli_log(f"No available MCP ports found (tried {base_port} to {base_port + 9})", log_type='warning')
            self.cli_log("Check if other processes are using these ports", log_type='info')
            self.cli_log("You can change the base port in ~/.ccmaster/config.json", log_type='info')
            self.mcp_enabled = False
            return
        
        try:
            self.mcp_server = MCPServer(self, self.mcp_host, self.mcp_port)
            if self.mcp_server.start():
                self.save_mcp_port(self.mcp_port)
                self.logger.info(f"MCP server started on {self.mcp_host}:{self.mcp_port}")
                self.cli_log(f"MCP server started on {self.mcp_host}:{self.mcp_port}", log_type='launch', color=Colors.GREEN)
            else:
                self.logger.error(f"Failed to start MCP server on port {self.mcp_port}")
                self.cli_log(f"Failed to start MCP server on port {self.mcp_port}", log_type='warning')
                self.cli_log("Check ~/.ccmaster/logs/ for details", log_type='info')
                self.mcp_enabled = False
        except Exception as e:
            self.logger.error(f"MCP server initialization error: {e}")
            self.cli_log(f"MCP server error: {e}", log_type='warning')
            import traceback
            self.logger.error(traceback.format_exc())
            self.mcp_enabled = False
    
    def stop_mcp_server(self):
        """Stop MCP server"""
        if self.mcp_server:
            self.mcp_server.stop()
            self.logger.info("MCP server stopped")
    
    def create_project_mcp_config(self, working_dir):
        """Add CCMaster MCP server to Claude Code using 'claude mcp add' command"""
        if not self.mcp_enabled or not self.mcp_port:
            self.logger.warning("MCP not enabled or no port allocated")
            return
            
        # Get the real path to handle symlinks
        script_path = os.path.abspath(__file__)
        if os.path.islink(script_path):
            script_path = os.path.realpath(script_path)
        
        # Get the ccmaster root directory (2 levels up from bin/ccmaster)
        ccmaster_root = os.path.dirname(os.path.dirname(os.path.dirname(script_path)))
        stdio_server_path = os.path.join(ccmaster_root, 'mcp', 'stdio_server.py')
        
        # Check if stdio_server.py exists
        if not os.path.exists(stdio_server_path):
            self.logger.error(f"MCP stdio_server.py not found at: {stdio_server_path}")
            self.cli_log(f"MCP stdio_server.py not found at: {stdio_server_path}", log_type='warning')
            return
        
        # First, check if ccmaster server is already configured
        check_cmd = ['claude', 'mcp', 'list']
        try:
            result = subprocess.run(check_cmd, capture_output=True, text=True, cwd=working_dir)
            if result.returncode == 0 and 'ccmaster' in result.stdout:
                # Remove existing ccmaster server first
                remove_cmd = ['claude', 'mcp', 'remove', 'ccmaster']
                subprocess.run(remove_cmd, capture_output=True, text=True, cwd=working_dir)
                self.logger.info("Removed existing ccmaster MCP server configuration")
        except Exception as e:
            self.logger.warning(f"Error checking existing MCP servers: {e}")
        
        # Build the claude mcp add command
        # Using project scope so it's saved in .mcp.json for the project
        mcp_add_cmd = [
            'claude', 'mcp', 'add',
            'ccmaster',  # server name
            '-s', 'project',  # project scope
            '--',  # separator for command
            sys.executable,  # Python interpreter
            stdio_server_path,
            '--host', self.mcp_host,
            '--port', str(self.mcp_port)
        ]
        
        self.cli_log(f"Running: {' '.join(mcp_add_cmd)}", log_type='info')
        
        # Execute the command
        try:
            result = subprocess.run(mcp_add_cmd, capture_output=True, text=True, cwd=working_dir)
            
            if result.returncode == 0:
                self.cli_log("Added CCMaster MCP server to Claude Code", log_type='info', color=Colors.GREEN)
                self.cli_log("Server: ccmaster (project scope)", log_type='info')
                self.cli_log(f"Port: {self.mcp_port}", log_type='info')
                self.cli_log(f"MCP tools will be available as: /mcp__ccmaster__<tool>", log_type='info', color=Colors.BLUE)
                
                self.logger.info(f"Successfully added CCMaster MCP server via 'claude mcp add'")
                
                # Verify it was added
                verify_cmd = ['claude', 'mcp', 'get', 'ccmaster']
                verify_result = subprocess.run(verify_cmd, capture_output=True, text=True, cwd=working_dir)
                if verify_result.returncode == 0:
                    self.logger.info(f"Verified MCP server configuration: {verify_result.stdout.strip()}")
                
                # Check if .mcp.json was created
                mcp_json_path = os.path.join(working_dir, '.mcp.json')
                if os.path.exists(mcp_json_path):
                    self.cli_log(f"✓ Created .mcp.json in {working_dir}", log_type='info', color=Colors.GREEN)
                else:
                    self.cli_log(f"Warning: .mcp.json not found in {working_dir}", log_type='warning')
                
                # Small delay to ensure file is written
                time.sleep(0.5)
                
                # Double-check the file exists and is readable
                if os.path.exists(mcp_json_path):
                    try:
                        with open(mcp_json_path, 'r') as f:
                            mcp_content = json.load(f)
                            self.cli_log(f"✓ Verified .mcp.json content: {len(mcp_content.get('mcpServers', {}))} servers", log_type='info', color=Colors.GREEN)
                    except Exception as e:
                        self.cli_log(f"Error reading .mcp.json: {e}", log_type='warning')
            else:
                error_msg = result.stderr.strip() or result.stdout.strip()
                self.logger.error(f"Failed to add MCP server: {error_msg}")
                self.cli_log(f"Failed to add MCP server: {error_msg}", log_type='warning')
                
                # Fallback message
                self.cli_log("You can manually add the MCP server with:", log_type='info')
                self.cli_log(f"claude mcp add ccmaster -s project -- {sys.executable} {stdio_server_path} --host {self.mcp_host} --port {self.mcp_port}", log_type='info')
                
        except FileNotFoundError:
            self.logger.error("'claude' command not found in PATH")
            self.cli_log("Error: 'claude' command not found. Make sure Claude Code is installed and in your PATH.", log_type='error')
            self.cli_log("To manually add the MCP server later:", log_type='info')
            self.cli_log(f"claude mcp add ccmaster -s project -- {sys.executable} {stdio_server_path} --host {self.mcp_host} --port {self.mcp_port}", log_type='info')
        except Exception as e:
            self.logger.error(f"Failed to execute 'claude mcp add': {e}")
            self.cli_log(f"Error executing 'claude mcp add': {e}", log_type='error')
    
    def create_claude_settings(self, working_dir):
        """Create .claude/settings.local.json to auto-enable MCP servers"""
        claude_dir = os.path.join(working_dir, '.claude')
        settings_file = os.path.join(claude_dir, 'settings.local.json')
        
        try:
            # Create .claude directory if it doesn't exist
            if not os.path.exists(claude_dir):
                os.makedirs(claude_dir)
                self.cli_log("✓ Created .claude directory", log_type='info', color=Colors.GREEN)
            
            # Create settings to auto-enable MCP servers
            settings = {
                "enabledMcpjsonServers": ["ccmaster"],
                "enableAllProjectMcpServers": True
            }
            
            # Check if settings file already exists
            if os.path.exists(settings_file):
                # Read existing settings
                try:
                    with open(settings_file, 'r') as f:
                        existing_settings = json.load(f)
                    
                    # Merge with our settings
                    if "enabledMcpjsonServers" not in existing_settings:
                        existing_settings["enabledMcpjsonServers"] = []
                    if "ccmaster" not in existing_settings["enabledMcpjsonServers"]:
                        existing_settings["enabledMcpjsonServers"].append("ccmaster")
                    existing_settings["enableAllProjectMcpServers"] = True
                    settings = existing_settings
                    self.cli_log("✓ Updated existing Claude settings", log_type='info', color=Colors.GREEN)
                except Exception as e:
                    self.cli_log(f"Could not read existing settings, creating new: {e}", log_type='warning')
            
            # Write settings file
            with open(settings_file, 'w') as f:
                json.dump(settings, f, indent=2)
            
            self.cli_log("✓ Created Claude settings to auto-enable MCP", log_type='info', color=Colors.GREEN)
            self.logger.info(f"Created Claude settings in {settings_file}")
            
        except Exception as e:
            self.logger.warning(f"Failed to create Claude settings: {e}")
            self.cli_log(f"Could not create Claude settings: {e}", log_type='warning')
    
    def remove_from_mcp_config(self, working_dir=None):
        """Remove CCMaster from Claude Code MCP configuration"""
        if working_dir is None:
            working_dir = os.getcwd()
        else:
            working_dir = os.path.abspath(working_dir)
        
        # Use claude mcp remove command
        remove_cmd = ['claude', 'mcp', 'remove', 'ccmaster']
        
        try:
            result = subprocess.run(remove_cmd, capture_output=True, text=True, cwd=working_dir)
            
            if result.returncode == 0:
                self.cli_log("Removed CCMaster MCP server from Claude Code", log_type='info')
                self.logger.info("Successfully removed CCMaster MCP server")
            else:
                error_msg = result.stderr.strip() or result.stdout.strip()
                if 'not found' in error_msg.lower():
                    self.cli_log("CCMaster MCP server not found in configuration", log_type='info')
                else:
                    self.cli_log(f"Error removing MCP server: {error_msg}", log_type='warning')
                    self.logger.error(f"Failed to remove MCP server: {error_msg}")
                    
        except FileNotFoundError:
            self.cli_log("Error: 'claude' command not found. Make sure Claude Code is installed and in your PATH.", log_type='error')
            self.logger.error("'claude' command not found in PATH")
        except Exception as e:
            self.cli_log(f"Error executing 'claude mcp remove': {e}", log_type='error')
            self.logger.error(f"Failed to execute 'claude mcp remove': {e}")
    
    def check_mcp_status(self):
        """Check MCP server status"""
        if self.mcp_enabled and self.mcp_server:
            server_info = self.mcp_server.get_server_info()
            self.cli_log("CCMaster MCP Server Status", log_type='info')
            self.cli_log(f"Running: {server_info['running']}", log_type='info', color=Colors.GREEN if server_info['running'] else Colors.RED)
            self.cli_log(f"Address: {server_info['host']}:{server_info['port']}", log_type='info')
            self.cli_log(f"Connected clients: {server_info['connected_clients']}", log_type='info')
            self.cli_log(f"Available tools: {len(server_info['available_tools'])}", log_type='info')
            for tool in server_info['available_tools']:
                self.cli_log(f"- {tool}", log_type='info')
            
            # Show port allocation info
            if self.mcp_port_file.exists():
                try:
                    with open(self.mcp_port_file, 'r') as f:
                        port_data = json.load(f)
                        self.cli_log(f"Port allocation: Dynamic (last used: {port_data.get('last_port')})", log_type='info')
                except Exception:
                    pass
            self.cli_log(f"Port range: {self.mcp_base_port}-{self.mcp_base_port + 9}", log_type='info')
        else:
            self.cli_log("MCP Server is disabled or not running", log_type='info', color=Colors.RED)
            if not self.mcp_enabled:
                self.cli_log("Enable in config: ~/.ccmaster/config.json", log_type='info')
            elif not self.mcp_server:
                self.cli_log("Start with: ccmaster watch", log_type='info')
                self.cli_log(f"Port range: {self.mcp_base_port}-{self.mcp_base_port + 9}", log_type='info')
    
    def create_session(self, working_dir):
        """Create a new session"""
        # Add microseconds to ensure unique IDs when creating multiple sessions quickly
        session_id = datetime.now().strftime('%Y%m%d_%H%M%S_%f')[:21]  # Trim to reasonable length
        session = {
            'id': session_id,
            'started_at': datetime.now().isoformat(),
            'working_dir': working_dir,
            'status': 'starting',
            'pid': None,
            'last_activity': datetime.now().isoformat()
        }
        self.sessions[session_id] = session
        self.save_sessions()
        return session_id
    
    def get_session_prefix(self, session_id):
        """Get session prefix for multi-session mode"""
        if session_id in self.active_sessions and len(self.active_sessions) >= 2:
            idx = self.active_sessions[session_id]['index']
            # Add MCP indicator for MCP-created sessions
            if session_id.startswith('mcp_'):
                return f"[MCP-{idx}]"
            else:
                return f"[{idx}]"
        return ""
    
    def log_event(self, session_id, event_type, message, display=True):
        """Log an event for a session"""
        log_file = self.logs_dir / f"{session_id}.log"
        timestamp = datetime.now()
        
        log_entry = {
            'timestamp': timestamp.isoformat(),
            'type': event_type,
            'message': message
        }
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
        
        if display and not self.should_stop:
            # For multi-agent compatibility, include session_id
            self.message_queue.put((session_id, 'LOG', timestamp, event_type, message))
    
    def create_hooks_config(self, session_id):
        """Create per-session hooks configuration"""
        claude_dir = Path.home() / '.claude'
        claude_dir.mkdir(exist_ok=True)
        
        # Settings file paths
        settings_file = claude_dir / 'settings.json'
        backup_file = claude_dir / 'settings.json.backup'
        
        # Backup existing settings if they exist
        if settings_file.exists():
            with open(settings_file, 'r') as f:
                existing_settings = json.load(f)
            with open(backup_file, 'w') as f:
                json.dump(existing_settings, f, indent=2)
        else:
            existing_settings = {}
        
        # Get the hooks directory path (resolve symlinks)
        real_path = Path(__file__).resolve()
        hooks_dir = real_path.parent.parent / 'hooks'
        
        # Create per-session hooks configuration with correct format
        # Use shell wrappers if they exist, otherwise fall back to direct Python
        pre_hook = hooks_dir / "pre_tool_use.sh"
        user_hook = hooks_dir / "user_prompt_submit.sh"
        stop_hook = hooks_dir / "stop_hook.sh"
        
        # Check if shell wrappers exist, otherwise use Python directly
        pre_cmd = f'bash {str(pre_hook)} {session_id}' if pre_hook.exists() else f'python3 {str(hooks_dir / "pre_tool_use.py")} {session_id}'
        user_cmd = f'bash {str(user_hook)} {session_id}' if user_hook.exists() else f'python3 {str(hooks_dir / "user_prompt_submit.py")} {session_id}'
        stop_cmd = f'bash {str(stop_hook)} {session_id}' if stop_hook.exists() else f'python3 {str(hooks_dir / "stop_hook.py")} {session_id}'
        
        hooks_config = {
            'hooks': {
                'PreToolUse': [{
                    'matcher': '.*',
                    'hooks': [{
                        'type': 'command',
                        'command': pre_cmd
                    }]
                }],
                'UserPromptSubmit': [{
                    'hooks': [{
                        'type': 'command',
                        'command': user_cmd
                    }]
                }],
                'Stop': [{
                    'hooks': [{
                        'type': 'command',
                        'command': stop_cmd
                    }]
                }]
            }
        }
        
        # Merge with existing settings
        if 'hooks' in existing_settings:
            # Store original hooks for restoration
            original_hooks = existing_settings.get('hooks', {})
            settings_file = Path.home() / '.claude' / 'settings.json'
            backup_file = self.config_dir / f'original_hooks_{session_id}.json'
            with open(backup_file, 'w') as f:
                json.dump(original_hooks, f, indent=2)
        
        existing_settings.update(hooks_config)
        
        # Write updated settings
        with open(settings_file, 'w') as f:
            json.dump(existing_settings, f, indent=2)
        
        return settings_file, backup_file
    
    def restore_hooks_config(self, session_id):
        """Restore original hooks configuration"""
        settings_file = Path.home() / '.claude' / 'settings.json'
        backup_file = Path.home() / '.claude' / 'settings.json.backup'
        
        # Restore from backup if it exists
        if backup_file.exists():
            with open(backup_file, 'r') as f:
                original_settings = json.load(f)
            with open(settings_file, 'w') as f:
                json.dump(original_settings, f, indent=2)
            backup_file.unlink()  # Remove backup
        else:
            # If no backup, just remove hooks
            if settings_file.exists():
                with open(settings_file, 'r') as f:
                    settings = json.load(f)
                if 'hooks' in settings:
                    del settings['hooks']
                with open(settings_file, 'w') as f:
                    json.dump(settings, f, indent=2)
    
    def format_status_line(self, status):
        """Format status line with appropriate color"""
        if status == 'idle':
            return f"{Colors.RED}● Idle{Colors.RESET}"
        elif status == 'processing':
            return f"{Colors.YELLOW}● Processing{Colors.RESET}"
        elif status == 'working':
            return f"{Colors.GREEN}● Working{Colors.RESET}"
        elif status == 'thinking':
            return f"{Colors.PURPLE}● Thinking{Colors.RESET}"
        else:
            return f"● {status}"
    
    def find_claude_process(self, session_id, start_time=None):
        """Find Claude process by command name"""
        time.sleep(2)  # Give Claude time to start
        
        # Try multiple methods to find the process
        methods_tried = []
        
        # Method 1: Using pgrep with full command
        try:
            result = subprocess.run(['pgrep', '-f', self.config['claude_code_command']], 
                                  capture_output=True, text=True)
            if result.returncode == 0 and result.stdout.strip():
                pids = result.stdout.strip().split('\n')
                methods_tried.append(f"pgrep found PIDs: {pids}")
                
                # Filter out our own process and ccmaster
                our_pid = os.getpid()
                for pid_str in pids:
                    try:
                        pid = int(pid_str)
                        if pid != our_pid:
                            # Verify it's actually Claude and not ccmaster
                            ps_result = subprocess.run(['ps', '-p', str(pid), '-o', 'command='],
                                                     capture_output=True, text=True)
                            if ps_result.returncode == 0:
                                command = ps_result.stdout.strip()
                                if 'claude' in command and 'ccmaster' not in command and 'python' not in command:
                                    self.log_event(session_id, 'DEBUG', f'Found Claude PID: {pid} via pgrep', display=False)
                                    return pid
                    except ValueError:
                        continue
        except Exception as e:
            methods_tried.append(f"pgrep error: {e}")
        
        # Method 2: Using ps aux with filtering
        try:
            result = subprocess.run(['ps', 'aux'], capture_output=True, text=True)
            if result.returncode == 0:
                our_pid = os.getpid()
                for line in result.stdout.strip().split('\n'):
                    if self.config['claude_code_command'] in line and 'ccmaster' not in line and 'python' not in line:
                        parts = line.split()
                        if len(parts) > 1:
                            try:
                                pid = int(parts[1])
                                if pid != our_pid:
                                    self.log_event(session_id, 'DEBUG', f'Found Claude PID: {pid} via ps aux', display=False)
                                    return pid
                            except ValueError:
                                continue
                methods_tried.append("ps aux found no matching processes")
        except Exception as e:
            methods_tried.append(f"ps aux error: {e}")
        
        self.log_event(session_id, 'WARNING', f'Could not find Claude process. Methods tried: {"; ".join(methods_tried)}', display=False)
        return None
    
    def monitor_session(self, session_id):
        """Monitor if the Claude session is still running"""
        # Wait for process to start and find its PID
        pid = self.find_claude_process(session_id)
        if pid:
            self.sessions[session_id]['pid'] = pid
            self.save_sessions()
            self.log_event(session_id, 'PROCESS', f'Monitoring Claude process (PID: {pid})', display=False)
        else:
            self.log_event(session_id, 'WARNING', 'Could not find Claude process PID, continuing anyway', display=False)
        
        consecutive_failures = 0
        max_failures = 3  # Allow 3 consecutive failures before declaring session ended
        
        while not self.should_stop:
            try:
                # Check if process is still running
                if pid:
                    try:
                        # Check if PID still exists
                        os.kill(pid, 0)
                        
                        # Double-check with pgrep to ensure Claude is really still running
                        result = subprocess.run(
                            ['pgrep', '-f', 'claude'],
                            capture_output=True, text=True
                        )
                        claude_still_running = False
                        if result.returncode == 0 and result.stdout.strip():
                            # Verify our specific PID is in the list
                            pids = result.stdout.strip().split('\n')
                            for pid_str in pids:
                                try:
                                    if int(pid_str) == pid:
                                        # Final check: make sure it's actually Claude
                                        ps_result = subprocess.run(['ps', '-p', str(pid), '-o', 'command='],
                                                                 capture_output=True, text=True)
                                        if ps_result.returncode == 0 and 'claude' in ps_result.stdout:
                                            claude_still_running = True
                                            break
                                except ValueError:
                                    continue
                        
                        if not claude_still_running:
                            consecutive_failures += 1
                            self.log_event(session_id, 'DEBUG', f'Claude process check failed ({consecutive_failures}/{max_failures})', display=False)
                            
                            if consecutive_failures >= max_failures:
                                self.log_event(session_id, 'SESSION_END', 'Claude session ended (process not found)')
                                break
                        else:
                            consecutive_failures = 0
                            self.log_event(session_id, 'DEBUG', f'Claude process {pid} still running', display=False)
                    except (OSError, ProcessLookupError):
                        consecutive_failures += 1
                        self.log_event(session_id, 'DEBUG', f'Process {pid} not found ({consecutive_failures}/{max_failures})', display=False)
                        
                        if consecutive_failures >= max_failures:
                            self.log_event(session_id, 'SESSION_END', 'Claude session ended (PID not found)')
                            break
                
                time.sleep(2)  # Check every 2 seconds
                
            except Exception as e:
                self.log_event(session_id, 'ERROR', f'Monitoring error: {str(e)}')
                break
    
    def is_claude_running(self, session_id):
        """Check if the Claude process for this specific session is running"""
        # First check if we have a PID stored for this session
        if session_id in self.sessions and 'claude_pid' in self.sessions[session_id]:
            pid = self.sessions[session_id]['claude_pid']
            try:
                # Check if specific PID is still running
                os.kill(pid, 0)  # Signal 0 checks if process exists
                # Double-check it's actually a Claude process
                result = subprocess.run(['ps', '-p', str(pid), '-o', 'command='], 
                                      capture_output=True, text=True)
                if result.returncode == 0 and self.config['claude_code_command'] in result.stdout:
                    return True
            except (OSError, ProcessLookupError):
                # Process doesn't exist
                pass
        
        # If we don't have a PID or it's not running, return False
        return False
    
    def find_claude_pid_for_session(self, session_id, start_time, max_attempts=10):
        """Find the PID of the Claude process we just launched"""
        for attempt in range(max_attempts):
            time.sleep(1)
            try:
                # Get all Claude processes started after our launch time
                result = subprocess.run(['ps', 'aux'], capture_output=True, text=True)
                if result.returncode == 0:
                    current_time = time.time()
                    for line in result.stdout.split('\n'):
                        if self.config['claude_code_command'] in line and 'ccmaster' not in line:
                            parts = line.split()
                            if len(parts) > 1:
                                pid = int(parts[1])
                                # Get process start time to ensure it's our process
                                stat_result = subprocess.run(['ps', '-p', str(pid), '-o', 'lstart='],
                                                           capture_output=True, text=True)
                                if stat_result.returncode == 0:
                                    # Check if this process started around our launch time
                                    # (within 5 seconds of our launch)
                                    if current_time - start_time < 5:
                                        return pid
            except Exception as e:
                self.log_event(session_id, 'DEBUG', f'Error finding Claude PID: {e}', display=False)
        
        return None
    
    def is_terminal_window_open(self, session_id):
        """Check if the Terminal window for this session is still open"""
        if session_id not in self.sessions or 'terminal_window_id' not in self.sessions[session_id]:
            return True  # If we don't have window info, assume it's open
        
        window_id = self.sessions[session_id]['terminal_window_id']
        
        # AppleScript to check if window exists
        check_script = f'''
        tell application "Terminal"
            try
                set w to window id {window_id}
                return "exists"
            on error
                return "not_found"
            end try
        end tell
        '''
        
        try:
            result = subprocess.run(['osascript', '-e', check_script], 
                                  capture_output=True, text=True, timeout=2)
            return result.returncode == 0 and result.stdout.strip() == "exists"
        except:
            return True  # On error, assume window is open
    
    def simple_monitor_session(self, session_id, launch_time):
        """Simple session monitoring that checks if the specific Claude process is still running"""
        consecutive_failures = 0
        max_failures = 5  # Allow 5 consecutive failures (10 seconds) before declaring dead
        
        # First, try to find the PID of the Claude process we launched
        claude_pid = self.find_claude_pid_for_session(session_id, launch_time)
        if claude_pid:
            self.sessions[session_id]['claude_pid'] = claude_pid
            self.save_sessions()
            self.log_event(session_id, 'DEBUG', f'Found Claude process PID: {claude_pid}', display=False)
            self.log_event(session_id, 'PROCESS', f'Tracking Claude process (PID: {claude_pid})', display=True)
        else:
            self.log_event(session_id, 'WARNING', 'Could not find Claude PID, monitoring may be less accurate', display=False)
        
        while True:
            try:
                # First check if the terminal window is still open
                if not self.is_terminal_window_open(session_id):
                    self.log_event(session_id, 'SESSION_END', 'Terminal window closed', display=True)
                    self.sessions[session_id]['status'] = 'ended'
                    self.sessions[session_id]['ended_at'] = datetime.now().isoformat()
                    self.save_sessions()
                    # Remove from active sessions to avoid CLI exit
                    if session_id in self.active_sessions:
                        del self.active_sessions[session_id]
                    self.log_event(session_id, 'SESSION_END', 'Claude session ended (terminal window closed)')
                    break
                
                # Then check if Claude process is running
                if self.is_claude_running(session_id):
                    consecutive_failures = 0
                    self.log_event(session_id, 'DEBUG', 'Claude process detected', display=False)
                else:
                    consecutive_failures += 1
                    self.log_event(session_id, 'DEBUG', f'Claude not detected, count: {consecutive_failures}/{max_failures}', display=False)
                    
                    if consecutive_failures >= max_failures:
                        self.cli_log("Claude session appears to have ended", log_type='end', newline_before=True)
                        self.sessions[session_id]['status'] = 'ended'
                        self.sessions[session_id]['ended_at'] = datetime.now().isoformat()
                        self.save_sessions()
                        # Remove from active sessions to avoid CLI exit
                        if session_id in self.active_sessions:
                            del self.active_sessions[session_id]
                        self.log_event(session_id, 'SESSION_END', 'Claude session ended (process not found)')
                        break
                
                time.sleep(2)  # Check every 2 seconds
                
            except Exception as e:
                self.log_event(session_id, 'ERROR', f'Monitoring error: {str(e)}')
                break
    
    def send_continue_to_claude(self, session_id, message="continue"):
        """Send message to the specific Claude session"""
        # Only use stored window and tab info - no fallback to avoid confusion
        if session_id not in self.sessions:
            self.cli_log("Session not found for auto-continue", log_type='warning')
            return False
            
        window_id = self.sessions[session_id].get('terminal_window_id')
        tab_index = self.sessions[session_id].get('terminal_tab_index')
        
        if not window_id or not tab_index:
            self.cli_log("No terminal window info stored for this session", log_type='warning')
            return False
        
        # Use specific window and find Claude tab
        specific_script = f'''
        tell application "Terminal"
            activate
            try
                -- Check if window still exists
                set targetWindow to window id {window_id}
                
                -- Find the tab running Claude in this window
                set foundTab to false
                repeat with t in tabs of targetWindow
                    try
                        if (processes of t) contains "claude" then
                            -- Found Claude tab, make it active and send continue
                            set foundTab to true
                            set frontmost of targetWindow to true
                            set selected of t to true
                            delay 0.3
                            
                            -- Type message and press return
                            tell application "System Events"
                                tell process "Terminal"
                                    keystroke "{message}"
                                    delay 0.1
                                    keystroke return
                                end tell
                            end tell
                            return "success"
                        end if
                    end try
                end repeat
                
                if not foundTab then
                    return "no_claude_in_window"
                end if
            on error
                return "window_not_found"
            end try
        end tell
        '''
        
        try:
            result = subprocess.run(['osascript', '-e', specific_script], 
                                  capture_output=True, text=True, timeout=5)
            
            if result.returncode == 0:
                output = result.stdout.strip()
                if output == "success":
                    return True
                elif output == "no_claude_in_window":
                    # Check if we're in multi-agent mode
                    prefix = self.get_session_prefix(session_id)
                    if prefix:
                        self.cli_log("Claude is no longer running in the tracked window", log_type='warning', prefix=prefix)
                    else:
                        self.cli_log("Claude is no longer running in the tracked window", log_type='warning')
                    return False
                elif output == "window_not_found":
                    prefix = self.get_session_prefix(session_id)
                    if prefix:
                        self.cli_log("The tracked terminal window no longer exists", log_type='warning', prefix=prefix)
                    else:
                        self.cli_log("The tracked terminal window no longer exists", log_type='warning')
                    return False
            
            prefix = self.get_session_prefix(session_id)
            if prefix:
                self.cli_log("Failed to send 'continue' command", log_type='error', prefix=prefix)
            else:
                self.cli_log("Failed to send 'continue' command", log_type='error')
            return False
            
        except Exception as e:
            prefix = self.get_session_prefix(session_id)
            if prefix:
                self.cli_log(f"Auto-continue error: {str(e)}", log_type='error', prefix=prefix)
            else:
                self.cli_log(f"Auto-continue error: {str(e)}", log_type='error')
            return False
    
    def start_session_and_monitor(self, working_dir=None, watch_mode=False, max_turns=None):
        """Start a new Claude session and monitor it"""
        # Always use current directory if not specified
        if working_dir is None:
            working_dir = os.getcwd()
        else:
            working_dir = os.path.abspath(working_dir)
        
        # Create session
        session_id = self.create_session(working_dir)
        
        # Register in active sessions
        self.active_sessions[session_id] = {
            'index': 1,
            'working_dir': working_dir,
            'created_at': datetime.now().isoformat()
        }
        self.watch_modes[session_id] = watch_mode
        self.auto_continue_counts[session_id] = 0
        self.has_seen_first_prompt[session_id] = False
        if max_turns:
            self.max_turns[session_id] = max_turns
        
        # Print session info
        self.cli_log(f"Starting Claude session in {working_dir}", log_type='launch')
        self.cli_log(f"Session ID: {session_id}", log_type='info')
        if watch_mode:
            if max_turns:
                self.cli_log("Watch mode: ON - Will auto-continue after idle", log_type='info', color=Colors.GREEN)
            else:
                self.cli_log("Watch mode: ON - Will auto-continue after idle", log_type='info', color=Colors.GREEN)
        else:
            self.cli_log("Watch mode: OFF - Press [w] to toggle", log_type='info')
        
        self.log_event(session_id, 'SESSION_START', f'Starting in {working_dir}', display=False)
        
        # Initialize MCP server if not already started
        if self.mcp_enabled and not self.mcp_server:
            self.cli_log("Initializing MCP server...", log_type='info', color=Colors.PURPLE)
            self.init_mcp_server()
        
        # Create project-scoped MCP configuration
        if self.mcp_enabled and self.mcp_server:
            self.cli_log(f"Creating MCP configuration in {working_dir}", log_type='info', color=Colors.PURPLE)
            self.create_project_mcp_config(working_dir)
            
            # Create Claude settings to auto-enable MCP
            self.create_claude_settings(working_dir)
        else:
            if not self.mcp_enabled:
                self.cli_log("MCP is disabled", log_type='warning')
            elif not self.mcp_server:
                self.cli_log("MCP server failed to start", log_type='warning')
        
        # Create per-session hooks configuration
        settings_file, backup_file = self.create_hooks_config(session_id)
        self.log_event(session_id, 'HOOKS', f'Created hooks configuration for session', display=False)
        
        # Prepare Claude Code command
        # Note: Claude needs to be started in the directory containing .mcp.json
        claude_cmd = self.config['claude_code_command'] + ' --dangerously-skip-permissions'
        
        # Debug: Show what directory we're launching in
        self.cli_log(f"Launching Claude Code in: {working_dir}", log_type='info')
        if os.path.exists(os.path.join(working_dir, '.mcp.json')):
            self.cli_log("✓ .mcp.json found in launch directory", log_type='info', color=Colors.GREEN)
        else:
            self.cli_log(".mcp.json NOT found in launch directory!", log_type='warning')
        
        # AppleScript to open Terminal and start Claude, returning window and tab info
        applescript = f'''
        tell application "Terminal"
            activate
            set newTab to do script "cd '{working_dir}' && pwd && ls -la .mcp.json 2>/dev/null && {claude_cmd}"
            set windowId to id of window 1
            -- Get the tab index
            set tabIndex to 1
            repeat with t in tabs of window 1
                if t is newTab then
                    exit repeat
                end if
                set tabIndex to tabIndex + 1
            end repeat
            return "" & windowId & "," & tabIndex
        end tell
        '''
        
        # Execute AppleScript and record launch time
        launch_time = time.time()
        result = subprocess.run(['osascript', '-e', applescript], 
                                capture_output=True, text=True)
        
        if result.returncode == 0:
            # Parse window and tab info
            try:
                window_tab_info = result.stdout.strip()
                if ',' in window_tab_info:
                    window_id, tab_index = window_tab_info.split(',')
                    self.sessions[session_id]['terminal_window_id'] = int(window_id)
                    self.sessions[session_id]['terminal_tab_index'] = int(tab_index)
                    self.log_event(session_id, 'LAUNCH', f'Launched Claude in Terminal (Window: {window_id}, Tab: {tab_index})', display=True)
                else:
                    self.log_event(session_id, 'LAUNCH', 'Launched Claude in Terminal', display=True)
            except Exception as e:
                self.log_event(session_id, 'LAUNCH', f'Launched Claude in Terminal (parse error: {e})', display=True)
        else:
            self.log_event(session_id, 'ERROR', f'Failed to launch Claude: {result.stderr}', display=True)
        
        # Update session status
        self.sessions[session_id]['status'] = 'running'
        self.save_sessions()
        
        # Start simple monitoring thread that checks if Claude is running
        monitor_thread = threading.Thread(
            target=self.simple_monitor_session,
            args=(session_id, launch_time),
            daemon=True
        )
        monitor_thread.start()
        
        # Start status monitoring thread
        status_thread = threading.Thread(
            target=self.monitor_status,
            args=(session_id,),
            daemon=True
        )
        status_thread.start()
        
        # Initial status
        current_status_display = self.format_status_line('idle')
        last_idle_time = {}
        
        # Initialize current_status for this session
        if isinstance(self.current_status, dict):
            self.current_status[session_id] = 'idle'
        
        # Set up terminal for keyboard input
        old_settings = termios.tcgetattr(sys.stdin)
        
        try:
            # Configure terminal for non-blocking input
            tty.setraw(sys.stdin.fileno())
            
            # Main monitoring loop
            while True:
                # Check for keyboard input
                key = self.check_keyboard_input()
                if key == 'q':
                    prefix = self.get_session_prefix(session_id)
                    self.cli_log("Stopping session monitor...", log_type='end', prefix=prefix, newline_before=True)
                    self.should_stop = True
                    break
                elif key == 'w':
                    current_count = self.auto_continue_counts.get(session_id, 0)
                    was_at_max_turns = max_turns and current_count >= max_turns
                    watch_mode = not watch_mode
                    self.watch_modes[session_id] = watch_mode
                    
                    timestamp = datetime.now()
                    time_str = timestamp.strftime('%H:%M:%S')
                    if watch_mode:
                        # Reset auto-continue count when toggling watch mode on after hitting max
                        if was_at_max_turns:
                            self.auto_continue_counts[session_id] = 0
                            prefix = self.get_session_prefix(session_id)
                            self.cli_log("Auto-continue count reset", log_type='info', prefix=prefix, color=Colors.GREEN)
                        
                        prefix = self.get_session_prefix(session_id)
                        if max_turns:
                            current_count = self.auto_continue_counts.get(session_id, 0)
                            remaining = max_turns - current_count
                            self.cli_log(f"Watch mode: ON - Will auto-continue after idle ({remaining} turns left)", log_type='info', prefix=prefix, color=Colors.GREEN)
                        else:
                            self.cli_log("Watch mode: ON - Will auto-continue after idle", log_type='info', prefix=prefix, color=Colors.GREEN)
                        
                        # If we're currently idle and re-enabling after max turns, set idle time for delayed continue
                        current_session_status = self.current_status.get(session_id) if isinstance(self.current_status, dict) else self.current_status
                        if was_at_max_turns and current_session_status == 'idle':
                            # Set idle time to trigger auto-continue after delay
                            last_idle_time[session_id] = time.time()
                    else:
                        prefix = self.get_session_prefix(session_id)
                        self.cli_log("Watch mode: OFF", log_type='info', prefix=prefix)
                        # Reset idle time tracking
                        last_idle_time.clear()
                
                # Process messages from queue
                try:
                    while True:
                        # Get 5-tuple message (session_id, msg_type, timestamp, event_type, message)
                        session_id_from_msg, msg_type, timestamp, event_type, message = self.message_queue.get_nowait()
                        
                        # Get session prefix for multi-session display
                        prefix = self.get_session_prefix(session_id_from_msg)
                        
                        if msg_type == 'STATUS':
                            # Handle status updates
                            if 'Working' in message:
                                self.current_status[session_id_from_msg] = 'working'
                                if 'tool:' in message:
                                    tool = message.split('tool:')[1].strip()
                                    self.cli_log(self.format_status_line('working'), log_type='status_working', prefix=prefix)
                                    self.cli_log(f"Using {tool}", log_type='tool', prefix=prefix)
                                else:
                                    self.cli_log(self.format_status_line('working'), log_type='status_working', prefix=prefix)
                            elif 'Processing' in message:
                                self.current_status[session_id_from_msg] = 'processing'
                                self.cli_log(self.format_status_line('processing'), log_type='status_processing', prefix=prefix)
                            elif 'Thinking' in message:
                                self.current_status[session_id_from_msg] = 'thinking'
                                self.cli_log(self.format_status_line('thinking'), log_type='status_thinking', prefix=prefix)
                            elif 'Idle' in message:
                                self.current_status[session_id_from_msg] = 'idle'
                                # Record when this session became idle for auto-continue delay
                                last_idle_time[session_id_from_msg] = time.time()
                                self.cli_log(self.format_status_line('idle'), log_type='status_idle', prefix=prefix)
                            
                        elif event_type == 'USER':
                            # Format user prompt
                            prompt_preview = message[:50] + '...' if len(message) > 50 else message
                            prompt_preview = prompt_preview.replace('\n', ' ')
                            self.cli_log(f"User: \"{prompt_preview}\"", log_type='user', prefix=prefix)
                            self.has_seen_first_prompt[session_id_from_msg] = True
                            # Reset idle time when user types
                            if session_id_from_msg in last_idle_time:
                                del last_idle_time[session_id_from_msg]
                            
                        elif event_type == 'SESSION_END':
                            self.cli_log(message, log_type='end', prefix=prefix, newline_before=True)
                            # Don't stop CLI - let the session removal logic handle it
                            
                        elif event_type == 'LAUNCH':
                            self.cli_log(message, log_type='launch', prefix=prefix)
                            
                        elif event_type == 'PROCESS':
                            self.cli_log(message, log_type='process', prefix=prefix)
                            
                        elif event_type == 'WARNING':
                            self.cli_log(message, log_type='warning', prefix=prefix)
                            
                        elif event_type == 'ERROR':
                            self.cli_log(message, log_type='error', prefix=prefix)
                            
                except queue.Empty:
                    pass
                
                # Check for session terminations and handle auto-continue for ALL active sessions (including MCP-created ones)
                for check_session_id in list(self.active_sessions.keys()):
                    if check_session_id not in self.current_status:
                        continue
                    
                    # First check if terminal window is still open
                    if not self.is_terminal_window_open(check_session_id):
                        prefix = self.get_session_prefix(check_session_id)
                        self.cli_log('Terminal window closed', log_type='end', prefix=prefix, newline_before=True)
                        # Update session status
                        if check_session_id in self.sessions:
                            self.sessions[check_session_id]['status'] = 'ended'
                            self.sessions[check_session_id]['ended_at'] = datetime.now().isoformat()
                            self.save_sessions()
                        # Remove from active sessions
                        del self.active_sessions[check_session_id]
                        # Clean up session tracking
                        if check_session_id in self.watch_modes:
                            del self.watch_modes[check_session_id]
                        if check_session_id in self.current_status:
                            del self.current_status[check_session_id]
                        if check_session_id in self.auto_continue_counts:
                            del self.auto_continue_counts[check_session_id]
                        if check_session_id in self.has_seen_first_prompt:
                            del self.has_seen_first_prompt[check_session_id]
                        if check_session_id in last_idle_time:
                            del last_idle_time[check_session_id]
                        continue
                    
                    # Get session-specific watch mode and status
                    session_watch_mode = self.watch_modes.get(check_session_id, watch_mode if check_session_id == session_id else False)
                    session_first_prompt = self.has_seen_first_prompt.get(check_session_id, False)
                    session_idle = self.current_status.get(check_session_id) == 'idle'
                    
                    # Handle auto-continue for each idle session with delay
                    if session_watch_mode and session_idle and session_first_prompt:
                        # Check if session has been idle long enough (2 seconds delay)
                        idle_time = last_idle_time.get(check_session_id, 0)
                        if idle_time > 0 and time.time() - idle_time >= 2.0:
                            session_max_turns = self.max_turns.get(check_session_id)
                            session_count = self.auto_continue_counts.get(check_session_id, 0)
                            
                            if session_max_turns is None or session_count < session_max_turns:
                                # Send continue to this specific session
                                if self.send_continue_to_claude(check_session_id):
                                    self.auto_continue_counts[check_session_id] = session_count + 1
                                    
                                    # Clear idle time to prevent immediate re-trigger
                                    if check_session_id in last_idle_time:
                                        del last_idle_time[check_session_id]
                                    
                                    # Log with session prefix
                                    prefix = self.get_session_prefix(check_session_id)
                                    
                                    if session_max_turns:
                                        msg = f"Auto-continue ({session_count + 1}/{session_max_turns})"
                                    else:
                                        msg = f"Auto-continue"
                                    
                                    if prefix:
                                        self.cli_log(msg, log_type='auto_continue', prefix=prefix, color=Colors.GREEN)
                                    else:
                                        self.cli_log(msg, log_type='auto_continue', color=Colors.GREEN)
                                    
                                    self.log_event(check_session_id, 'AUTO_CONTINUE', f'Sent auto-continue #{session_count + 1}', display=False)
                            else:
                                # Max turns reached, disable watch mode for this session
                                self.watch_modes[check_session_id] = False
                                prefix = self.get_session_prefix(check_session_id)
                                self.cli_log(f"Max auto-continue turns ({session_max_turns}) reached - Watch mode disabled", log_type='warning', prefix=prefix)
                                self.cli_log("Press [w] to re-enable and continue", log_type='info', prefix=prefix)
                                if check_session_id in last_idle_time:
                                    del last_idle_time[check_session_id]
                
                # Only break if user requested stop or no sessions remain
                if self.should_stop:
                    break
                
                # Stop if no active sessions remain
                if not self.active_sessions:
                    self.cli_log("All sessions ended. Exiting...", log_type='end', newline_before=True)
                    break
                
                # Small sleep to prevent busy-waiting
                time.sleep(0.1)
                
        except KeyboardInterrupt:
            self.cli_log("Session interrupted by user", log_type='end', newline_before=True)
        finally:
            # Restore terminal settings
            termios.tcsetattr(sys.stdin, termios.TCSADRAIN, old_settings)
            self.cli_log("Session ended", log_type='end', newline_before=True)
            
            # Update session status
            if session_id in self.sessions:
                self.sessions[session_id]['status'] = 'ended'
                self.sessions[session_id]['ended_at'] = datetime.now().isoformat()
                self.save_sessions()
            
            # Restore original hooks configuration
            self.restore_hooks_config(session_id)
    
    def check_keyboard_input(self):
        """Check for keyboard input without blocking"""
        if sys.stdin in select.select([sys.stdin], [], [], 0)[0]:
            return sys.stdin.read(1)
        return None
    
    def safe_print(self, message, old_settings):
        """Safely print in raw terminal mode - now delegates to cli_log for consistency"""
        # Parse the message to determine type and extract components
        if '●' in message:
            if 'Idle' in message:
                self.cli_log('Idle', log_type='status_idle')
            elif 'Working' in message:
                self.cli_log('Working', log_type='status_working')
            elif 'Processing' in message:
                self.cli_log('Processing', log_type='status_processing')
            elif 'Thinking' in message:
                self.cli_log('Thinking', log_type='status_thinking')
        elif '▶ User:' in message:
            # Extract user message
            user_msg = message.split('▶ User: "')[1].rstrip('"')
            self.cli_log(f'User: "{user_msg}"', log_type='user')
        elif '→ Using' in message:
            # Extract tool name
            tool = message.split('→ Using ')[1]
            self.cli_log(f'Using {tool}', log_type='tool')
        elif '▶ Auto-continue' in message:
            # Extract auto-continue info
            parts = message.split('▶ ')
            if len(parts) > 1:
                self.cli_log(parts[1], log_type='auto_continue', color=Colors.GREEN)
        elif '⟐' in message:
            self.cli_log(message.split('⟐ ')[1], log_type='launch')
        elif '◎' in message:
            self.cli_log(message.split('◎ ')[1], log_type='process')
        elif '▲' in message:
            self.cli_log(message.split('▲ ')[1], log_type='warning')
        elif '✖' in message:
            self.cli_log(message.split('✖ ')[1], log_type='error')
        elif '■' in message:
            self.cli_log(message.split('■ ')[1], log_type='end')
        else:
            # For any other message, just print it as-is
            with self.print_lock:
                termios.tcsetattr(sys.stdin, termios.TCSADRAIN, old_settings)
                self.cli_log(message, log_type='info')
                tty.setraw(sys.stdin.fileno())
    
    # thread_safe_print method removed - all printing now goes through cli_log
    
    def is_terminal_window_open(self, session_id):
        """Check if the Terminal window for this session is still open"""
        if session_id not in self.sessions or 'terminal_window_id' not in self.sessions[session_id]:
            return True  # If we don't have window info, assume it's open
        
        window_id = self.sessions[session_id]['terminal_window_id']
        
        # AppleScript to check if window exists
        check_script = f'''
        tell application "Terminal"
            try
                set w to window id {window_id}
                return "exists"
            on error
                return "not_found"
            end try
        end tell
        '''
        
        try:
            result = subprocess.run(['osascript', '-e', check_script], capture_output=True, text=True)
            if result.returncode == 0:
                return result.stdout.strip() == "exists"
            return False
        except Exception:
            return True  # If we can't check, assume it's still open
    
    def cli_log(self, message, log_type='info', prefix='', color=None, newline_before=False, session_id=None):
        """
        Standardized CLI logging with proper alignment and thread safety
        
        Args:
            message: The message to log
            log_type: Type of log ('info', 'status', 'warning', 'error', 'mcp', 'user', 'tool')
            prefix: Optional prefix (e.g., '[1]' for multi-session)
            color: Optional color override (Colors.GREEN, etc.)
            newline_before: Add newline before message
            session_id: Session ID for context
        """
        # Get timestamp
        timestamp = datetime.now().strftime('%H:%M:%S')
        
        # Determine color based on type if not specified
        if color is None:
            color_map = {
                'warning': Colors.YELLOW,
                'error': Colors.RED,
                'success': Colors.GREEN,
                'mcp': '\033[96m',  # Cyan
                'tool': Colors.ORANGE,  # Changed to orange
            }
            color = color_map.get(log_type, '')
        
        # Format symbols based on type
        symbol_map = {
            'status_idle': '●',
            'status_working': '●',
            'status_processing': '●',
            'status_thinking': '●',
            'launch': '⟐',
            'process': '◎',
            'user': '▶',
            'tool': '→',
            'warning': '▲',
            'error': '✖',
            'end': '■',
            'mcp': '[MCP]',
            'auto_continue': '▶',
            'info': '◆',
        }
        symbol = symbol_map.get(log_type, '')
        
        # Build the formatted message
        if prefix:
            formatted_msg = f"{prefix}[{timestamp}] "
        else:
            formatted_msg = f"[{timestamp}] "
        
        if symbol:
            formatted_msg += f"{symbol} "
        
        formatted_msg += message
        
        # Apply color
        if color:
            if color == '\033[96m':  # Cyan for MCP
                formatted_msg = f"{color}{formatted_msg}\033[0m"
            else:
                formatted_msg = f"{color}{formatted_msg}{Colors.RESET}"
        
        # Add newline before if requested
        if newline_before:
            formatted_msg = '\n' + formatted_msg
        
        # Use thread-safe printing with proper cleanup
        with self.print_lock:
            try:
                # Save current cursor position and clear line
                sys.stdout.write('\r\033[K')  # Move to start of line and clear
                
                # Try to get current terminal settings (in case we're in raw mode)
                try:
                    old_settings = termios.tcgetattr(sys.stdin)
                    is_raw_mode = True
                    # Temporarily switch to normal mode
                    termios.tcsetattr(sys.stdin, termios.TCSADRAIN, old_settings)
                except:
                    is_raw_mode = False
                
                # Print the formatted message
                print(formatted_msg)
                sys.stdout.flush()
                
                # Return to raw mode if we were in it
                if is_raw_mode:
                    try:
                        tty.setraw(sys.stdin.fileno())
                    except:
                        pass
            except Exception as e:
                # Fallback: just print
                print(formatted_msg)
                sys.stdout.flush()
    
    def monitor_status(self, session_id):
        """Monitor the status file for updates"""
        status_file = self.status_dir / f"{session_id}.json"
        
        # Create an empty status file
        with open(status_file, 'w') as f:
            json.dump({'state': 'idle', 'session_id': session_id}, f)
        
        last_update = None
        
        while not self.should_stop:
            try:
                # Check if status file exists and has been updated
                if status_file.exists():
                    with open(status_file, 'r') as f:
                        try:
                            status_data = json.load(f)
                            current_update = status_data.get('timestamp')
                            
                            if current_update != last_update:
                                last_update = current_update
                                state = status_data.get('state', 'idle')
                                # For multi-agent compatibility, use dictionary
                                if isinstance(self.current_status, dict):
                                    self.current_status[session_id] = state
                                else:
                                    self.current_status = state
                                
                                # Format and queue the status message
                                if state == 'working':
                                    tool = status_data.get('last_tool', '')
                                    message = f"Working - tool: {tool}"
                                elif state == 'processing':
                                    message = "Processing"
                                elif state == 'thinking':
                                    message = "Thinking"
                                else:
                                    message = "Idle"
                                
                                # For multi-agent compatibility, always include session_id
                                self.message_queue.put((session_id, 'STATUS', datetime.now(), 'STATUS', message))
                                
                                # Check for user prompts
                                if state == 'processing' and 'prompt' in status_data:
                                    prompt = status_data['prompt']
                                    # For multi-agent compatibility
                                    self.message_queue.put((session_id, 'USER', datetime.now(), 'USER', prompt))
                                    
                                    # Log the prompt to the prompts file
                                    prompt_log_file = self.logs_dir / f"{session_id}_prompts.log"
                                    with open(prompt_log_file, 'a') as pf:
                                        log_entry = {
                                            'timestamp': datetime.now().isoformat(),
                                            'prompt': prompt
                                        }
                                        pf.write(json.dumps(log_entry) + '\n')
                        except json.JSONDecodeError:
                            pass
                
                time.sleep(self.config['monitor_interval'])
                
            except Exception as e:
                if not self.should_stop:
                    self.log_event(session_id, 'ERROR', f'Status monitoring error: {str(e)}')
    
    def list_sessions(self):
        """List all sessions"""
        if not self.sessions:
            self.cli_log("No sessions found.", log_type='info')
            return
        
        self.cli_log("Sessions:", log_type='info')
        self.cli_log(f"{'ID':<20} {'Status':<10} {'Started':<20} {'Directory'}", log_type='info')
        self.cli_log("-" * 80, log_type='info')
        
        for session_id, session in sorted(self.sessions.items(), reverse=True):
            started = datetime.fromisoformat(session['started_at']).strftime('%Y-%m-%d %H:%M:%S')
            status = session['status']
            if status == 'running':
                status_colored = f"{Colors.GREEN}{status}{Colors.RESET}"
            elif status == 'ended':
                status_colored = f"{Colors.RED}{status}{Colors.RESET}"
            else:
                status_colored = status
            
            # Format status without color codes for alignment
            status_str = f"{session_id:<20} {status:<10} {started:<20} {session['working_dir']}"
            if status == 'running':
                self.cli_log(status_str, log_type='info', color=Colors.GREEN)
            elif status == 'ended':
                self.cli_log(status_str, log_type='info', color=Colors.RED)
            else:
                self.cli_log(status_str, log_type='info')
    
    def view_logs(self, session_id):
        """View logs for a specific session"""
        log_file = self.logs_dir / f"{session_id}.log"
        if not log_file.exists():
            self.cli_log(f"No logs found for session {session_id}", log_type='warning')
            return
        
        self.cli_log(f"Logs for session {session_id}:", log_type='info')
        self.cli_log("-" * 80, log_type='info')
        
        with open(log_file, 'r') as f:
            for line in f:
                try:
                    entry = json.loads(line)
                    timestamp = datetime.fromisoformat(entry['timestamp']).strftime('%H:%M:%S')
                    event_type = entry['type']
                    message = entry['message']
                    
                    # Color code by event type
                    if event_type == 'ERROR':
                        type_colored = f"{Colors.RED}{event_type}{Colors.RESET}"
                    elif event_type == 'SESSION_START':
                        type_colored = f"{Colors.GREEN}{event_type}{Colors.RESET}"
                    elif event_type == 'SESSION_END':
                        type_colored = f"{Colors.YELLOW}{event_type}{Colors.RESET}"
                    else:
                        type_colored = event_type
                    
                    # Format log entry with appropriate color
                    log_str = f"[{timestamp}] {event_type:<20} {message}"
                    if event_type == 'ERROR':
                        self.cli_log(log_str, log_type='error')
                    elif event_type == 'SESSION_START':
                        self.cli_log(log_str, log_type='info', color=Colors.GREEN)
                    elif event_type == 'SESSION_END':
                        self.cli_log(log_str, log_type='warning')
                    else:
                        self.cli_log(log_str, log_type='info')
                except json.JSONDecodeError:
                    self.cli_log(line.strip(), log_type='info')
    
    def view_prompts(self, session_id):
        """View user prompts for a specific session"""
        prompt_file = self.logs_dir / f"{session_id}_prompts.log"
        if not prompt_file.exists():
            self.cli_log(f"No prompts found for session {session_id}", log_type='warning')
            return
        
        self.cli_log(f"User prompts for session {session_id}:", log_type='info')
        self.cli_log("-" * 80, log_type='info')
        
        with open(prompt_file, 'r') as f:
            for line in f:
                try:
                    entry = json.loads(line)
                    timestamp = datetime.fromisoformat(entry['timestamp']).strftime('%Y-%m-%d %H:%M:%S')
                    prompt = entry['prompt']
                    
                    self.cli_log(f"[{timestamp}]", log_type='info', color=Colors.BLUE)
                    self.cli_log(prompt, log_type='info')
                    self.cli_log("-" * 40, log_type='info')
                except json.JSONDecodeError:
                    self.cli_log(line.strip(), log_type='info')

    def start_multi_session_and_monitor(self, working_dir=None, watch_mode=False, max_turns=None, num_instances=2):
        """Start multiple Claude sessions and monitor them concurrently"""
        # Always use current directory if not specified
        if working_dir is None:
            working_dir = os.getcwd()
        else:
            working_dir = os.path.abspath(working_dir)
        
        self.cli_log(f"Starting {num_instances} Claude sessions in {working_dir}", log_type='launch')
        if watch_mode:
            if max_turns:
                self.cli_log(f"Watch mode: ON - Will auto-continue after idle (max {max_turns} turns per session)", log_type='info', color=Colors.GREEN)
            else:
                self.cli_log("Watch mode: ON - Will auto-continue after idle", log_type='info', color=Colors.GREEN)
        else:
            self.cli_log("Watch mode: OFF - Press [w] to toggle for all sessions", log_type='info')
        
        # Create all sessions
        session_ids = []
        for i in range(num_instances):
            session_id = self.create_session(working_dir)
            session_ids.append(session_id)
            self.active_sessions[session_id] = {
                'index': i + 1,
                'working_dir': working_dir,
                'status': 'starting'
            }
            self.current_status[session_id] = 'idle'
            self.watch_modes[session_id] = watch_mode
            self.auto_continue_counts[session_id] = 0
            self.max_turns[session_id] = max_turns
            self.has_seen_first_prompt[session_id] = False
            
            # Add MCP indicator for MCP-created sessions
            if session_id.startswith('mcp_'):
                self.cli_log(f"Session ID: {session_id}", log_type='info', prefix=f"[MCP-{i+1}]")
            else:
                self.cli_log(f"Session ID: {session_id}", log_type='info', prefix=f"[{i+1}]")
            self.log_event(session_id, 'SESSION_START', f'Starting session {i+1} of {num_instances} in {working_dir}', display=False)
        
        # Launch all sessions with slight delay between each
        for i, session_id in enumerate(session_ids):
            # Create per-session hooks configuration
            settings_file, backup_file = self.create_hooks_config(session_id)
            self.log_event(session_id, 'HOOKS', f'Created hooks configuration for session', display=False)
            
            # Prepare Claude Code command
            claude_cmd = self.config['claude_code_command'] + ' --dangerously-skip-permissions'
            
            # AppleScript to open Terminal and start Claude
            applescript = f'''
            tell application "Terminal"
                activate
                set newTab to do script "cd '{working_dir}' && pwd && ls -la .mcp.json 2>/dev/null && {claude_cmd}"
                set windowId to id of window 1
                set tabIndex to 1
                repeat with t in tabs of window 1
                    if t is newTab then
                        exit repeat
                    end if
                    set tabIndex to tabIndex + 1
                end repeat
                return "" & windowId & "," & tabIndex
            end tell
            '''
            
            # Execute AppleScript
            launch_time = time.time()
            result = subprocess.run(['osascript', '-e', applescript], 
                                    capture_output=True, text=True)
            
            if result.returncode == 0:
                # Parse window and tab info
                try:
                    window_tab_info = result.stdout.strip()
                    if ',' in window_tab_info:
                        window_id, tab_index = window_tab_info.split(',')
                        self.sessions[session_id]['terminal_window_id'] = int(window_id)
                        self.sessions[session_id]['terminal_tab_index'] = int(tab_index)
                        self.active_sessions[session_id]['terminal_window_id'] = int(window_id)
                        self.active_sessions[session_id]['terminal_tab_index'] = int(tab_index)
                        self.log_event(session_id, 'LAUNCH', f'Launched Claude in Terminal (Window: {window_id}, Tab: {tab_index})', display=True)
                except Exception as e:
                    self.log_event(session_id, 'LAUNCH', 'Launched Claude in Terminal', display=True)
            else:
                self.log_event(session_id, 'ERROR', f'Failed to launch Claude: {result.stderr}', display=True)
            
            # Update session status
            self.sessions[session_id]['status'] = 'running'
            self.active_sessions[session_id]['status'] = 'running'
            self.save_sessions()
            
            # Start monitoring threads for this session
            monitor_thread = threading.Thread(
                target=self.simple_monitor_session,
                args=(session_id, launch_time),
                daemon=True
            )
            monitor_thread.start()
            self.session_threads[session_id] = {'monitor': monitor_thread}
            
            status_thread = threading.Thread(
                target=self.monitor_status,
                args=(session_id,),
                daemon=True
            )
            status_thread.start()
            self.session_threads[session_id]['status'] = status_thread
            
            # Small delay between launching sessions
            if i < num_instances - 1:
                time.sleep(1)
        
        self.cli_log("All sessions launched. Monitoring...", log_type='launch', newline_before=True)
        self.cli_log("Press [q] to quit, [w] to toggle watch mode for all sessions", log_type='info', newline_before=True)
        
        # Message printer thread for multi-agent
        printer_thread = threading.Thread(
            target=self.multi_session_message_printer,
            daemon=True
        )
        printer_thread.start()
        
        # Set up terminal for keyboard input
        old_settings = termios.tcgetattr(sys.stdin)
        
        try:
            # Configure terminal for non-blocking input
            tty.setraw(sys.stdin.fileno())
            
            # Main monitoring loop
            while not self.should_stop:
                # Check for keyboard input
                key = self.check_keyboard_input()
                if key == 'q':
                    self.cli_log("Stopping all session monitors...", log_type='end', newline_before=True)
                    self.should_stop = True
                    break
                elif key == 'w':
                    # Toggle watch mode for all sessions
                    new_watch_mode = not any(self.watch_modes.values())
                    for sid in self.active_sessions:
                        self.watch_modes[sid] = new_watch_mode
                        if new_watch_mode and self.max_turns[sid] and self.auto_continue_counts[sid] >= self.max_turns[sid]:
                            self.auto_continue_counts[sid] = 0
                    
                    if new_watch_mode:
                        self.cli_log("Watch mode: ON for all sessions", log_type='info', color=Colors.GREEN, newline_before=True)
                    else:
                        self.cli_log("Watch mode: OFF for all sessions", log_type='info', newline_before=True)
                
                # Check session statuses and handle auto-continue
                for session_id in list(self.active_sessions.keys()):
                    if session_id not in self.current_status:
                        continue
                        
                    # Check if terminal window is still open
                    if not self.is_terminal_window_open(session_id):
                        idx = self.active_sessions[session_id]['index']
                        self.message_queue.put((session_id, 'SESSION_END', datetime.now(), 'SESSION_END', f'Terminal window closed'))
                        del self.active_sessions[session_id]
                        continue
                    
                    # Handle auto-continue for idle sessions (only after first prompt)
                    if (self.watch_modes.get(session_id, False) and 
                        self.current_status.get(session_id) == 'idle' and
                        self.has_seen_first_prompt.get(session_id, False) and
                        session_id in self.active_sessions):
                        
                        max_t = self.max_turns.get(session_id)
                        count = self.auto_continue_counts.get(session_id, 0)
                        
                        if max_t is None or count < max_t:
                            # Send continue to this specific session
                            if self.send_continue_to_claude(session_id):
                                self.auto_continue_counts[session_id] = count + 1
                                idx = self.active_sessions[session_id]['index']
                                self.message_queue.put((session_id, 'AUTO_CONTINUE', datetime.now(), 'AUTO_CONTINUE', 
                                                      f'Auto-continue ({count + 1}/{max_t if max_t else "∞"})'))
                
                # Small sleep to prevent busy-waiting
                time.sleep(2)
                
        except KeyboardInterrupt:
            self.cli_log("Sessions interrupted by user", log_type='end', newline_before=True)
        finally:
            # Restore terminal settings
            termios.tcsetattr(sys.stdin, termios.TCSADRAIN, old_settings)
            self.cli_log("All sessions ended.", log_type='end', newline_before=True)
            
            # Update session statuses
            for session_id in session_ids:
                if session_id in self.sessions:
                    self.sessions[session_id]['status'] = 'ended'
                    self.sessions[session_id]['ended_at'] = datetime.now().isoformat()
                self.save_sessions()
                
                # Restore original hooks configuration
                self.restore_hooks_config(session_id)
    
    def multi_session_message_printer(self):
        """Print messages for multiple concurrent sessions"""
        
        # Get the terminal settings to restore after each print
        import termios
        import tty
        try:
            old_settings = termios.tcgetattr(sys.stdin)
        except:
            old_settings = None
            
        while not self.should_stop:
            try:
                session_id, msg_type, timestamp, event_type, message = self.message_queue.get(timeout=0.1)
                
                if session_id not in self.active_sessions:
                    continue
                    
                idx = self.active_sessions[session_id]['index']
                time_str = timestamp.strftime('%H:%M:%S')
                prefix = f"[{idx}]"
                
                # Use lock to ensure thread-safe printing
                with self.print_lock:
                    # Format message based on type
                    if msg_type == 'STATUS':
                        # Extract status from message
                        if 'Working' in message:
                            status = 'working'
                            tool = message.split('tool:')[1].strip() if 'tool:' in message else None
                        elif 'Processing' in message:
                            status = 'processing'
                            tool = None
                        elif 'Thinking' in message:
                            status = 'thinking'
                            tool = None
                        else:
                            status = 'idle'
                            tool = None
                        
                        self.current_status[session_id] = status
                        
                        # Format status line - clean output without \r
                        status_line = self.format_status_line(status)
                        
                        # Temporarily switch out of raw mode for clean printing
                        if old_settings:
                            termios.tcsetattr(sys.stdin, termios.TCSADRAIN, old_settings)
                        self.cli_log(status_line, log_type=f'status_{status}', prefix=prefix)
                        if tool:
                            self.cli_log(f"Using {tool}", log_type='tool', prefix=prefix)
                        sys.stdout.flush()
                        if old_settings:
                            tty.setraw(sys.stdin.fileno())
                            
                    elif event_type == 'USER':
                        prompt_preview = message[:50] + '...' if len(message) > 50 else message
                        prompt_preview = prompt_preview.replace('\n', ' ')
                        # Temporarily switch out of raw mode
                        if old_settings:
                            termios.tcsetattr(sys.stdin, termios.TCSADRAIN, old_settings)
                        self.cli_log(f"User: \"{prompt_preview}\"", log_type='user', prefix=prefix)
                        sys.stdout.flush()
                        if old_settings:
                            tty.setraw(sys.stdin.fileno())
                        # Mark that this session has seen its first prompt
                        self.has_seen_first_prompt[session_id] = True
                        
                    else:
                        # For all other message types, use same pattern
                        if old_settings:
                            termios.tcsetattr(sys.stdin, termios.TCSADRAIN, old_settings)
                            
                        if event_type == 'AUTO_CONTINUE':
                            self.cli_log(message, log_type='auto_continue', prefix=prefix, color=Colors.GREEN)
                        elif event_type == 'SESSION_END':
                            self.cli_log(message, log_type='end', prefix=prefix)
                        elif event_type == 'PROCESS':
                            self.cli_log(message, log_type='process', prefix=prefix)
                        elif event_type == 'LAUNCH':
                            self.cli_log(message, log_type='launch', prefix=prefix)
                        elif event_type == 'WARNING':
                            self.cli_log(message, log_type='warning', prefix=prefix)
                        elif event_type == 'ERROR':
                            self.cli_log(message, log_type='error', prefix=prefix)
                        else:
                            # Generic log message
                            self.cli_log(message, log_type='info', prefix=prefix)
                            
                        sys.stdout.flush()
                        if old_settings:
                            tty.setraw(sys.stdin.fileno())
                
            except queue.Empty:
                continue
            except Exception as e:
                if not self.should_stop:
                    with self.print_lock:
                        self.cli_log(f"Error in multi-session printer: {e}", log_type='error', newline_before=True)

def main():
    parser = argparse.ArgumentParser(description='CCMaster - Claude Code Session Manager')
    
    subparsers = parser.add_subparsers(dest='command', help='Commands')
    
    # Start command (default)
    start_parser = subparsers.add_parser('start', help='Start a new Claude session')
    start_parser.add_argument('-d', '--dir', help='Working directory (defaults to current directory)')
    
    # Watch mode command
    watch_parser = subparsers.add_parser('watch', help='Start in watch mode (auto-continue)')
    watch_parser.add_argument('-d', '--dir', help='Working directory (defaults to current directory)')
    watch_parser.add_argument('--maxturn', type=int, help='Maximum number of auto-continue turns')
    watch_parser.add_argument('--instances', type=int, default=1, help='Number of Claude sessions to manage (default: 1)')
    
    # List command
    list_parser = subparsers.add_parser('list', help='List all sessions')
    
    # Logs command
    logs_parser = subparsers.add_parser('logs', help='View logs for a session')
    logs_parser.add_argument('session_id', help='Session ID')
    
    # Prompts command
    prompts_parser = subparsers.add_parser('prompts', help='View user prompts for a session')
    prompts_parser.add_argument('session_id', help='Session ID')
    
    # Version command
    version_parser = subparsers.add_parser('version', help='Show CCMaster version')
    
    # MCP management commands
    mcp_parser = subparsers.add_parser('mcp', help='MCP management commands')
    mcp_subparsers = mcp_parser.add_subparsers(dest='mcp_command', help='MCP commands')
    
    # MCP remove command
    mcp_remove_parser = mcp_subparsers.add_parser('remove', help='Remove CCMaster from project .mcp.json')
    mcp_remove_parser.add_argument('-d', '--dir', help='Project directory (defaults to current directory)')
    
    # MCP status command
    mcp_status_parser = mcp_subparsers.add_parser('status', help='Check MCP server status')
    
    args = parser.parse_args()
    
    cc = CCMaster()
    
    # Cleanup function
    def cleanup():
        cc.stop_mcp_server()
        cc.should_stop = True
    
    # Register cleanup for graceful shutdown
    import atexit
    atexit.register(cleanup)
    
    # Default to 'start' if no command specified
    if args.command is None:
        args.command = 'start'
        args.dir = None
    
    try:
        if args.command == 'start':
            cc.start_session_and_monitor(args.dir if hasattr(args, 'dir') else None)
        elif args.command == 'watch':
            if args.instances > 1:
                cc.start_multi_session_and_monitor(args.dir, watch_mode=True, max_turns=args.maxturn, num_instances=args.instances)
            else:
                cc.start_session_and_monitor(args.dir, watch_mode=True, max_turns=args.maxturn)
        elif args.command == 'list':
            cc.list_sessions()
        elif args.command == 'logs':
            cc.view_logs(args.session_id)
        elif args.command == 'prompts':
            cc.view_prompts(args.session_id)
        elif args.command == 'version':
            cc.cli_log(f"CCMaster version {__version__}", log_type='info')
            cc.cli_log("Claude Code Session Manager", log_type='launch')
            cc.cli_log("https://github.com/yourusername/ccmaster", log_type='info')
        elif args.command == 'mcp':
            if args.mcp_command == 'remove':
                cc.remove_from_mcp_config(args.dir)
            elif args.mcp_command == 'status':
                cc.check_mcp_status()
            else:
                cc.cli_log("Usage: ccmaster mcp [remove|status]", log_type='info')
    finally:
        cleanup()

if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        print("\nShutting down CCMaster...")
        # Cleanup will be handled by the CCMaster instance
        sys.exit(0)
    except Exception as e:
        print(f"Error: {e}")
        sys.exit(1)