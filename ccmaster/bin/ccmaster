#!/usr/bin/env python3
"""
CCMaster - Claude Code Session Manager
Manages Claude Code sessions with automatic terminal launching and continuous monitoring
"""

import os
import sys
import json
import time
import subprocess
import argparse
import threading
import queue
import select
import tty
import termios
from pathlib import Path
from datetime import datetime

# Color codes for terminal output
class Colors:
    GREEN = '\033[92m'
    RED = '\033[91m'
    YELLOW = '\033[93m'
    BLUE = '\033[94m'
    RESET = '\033[0m'
    BOLD = '\033[1m'

class CCMaster:
    def __init__(self):
        self.config_dir = Path.home() / '.ccmaster'
        self.config_file = self.config_dir / 'config.json'
        self.sessions_file = self.config_dir / 'sessions.json'
        self.status_dir = self.config_dir / 'status'
        self.logs_dir = self.config_dir / 'logs'
        self.hooks_dir = Path(__file__).resolve().parent.parent / 'hooks'
        
        # Create directories
        self.config_dir.mkdir(exist_ok=True)
        self.logs_dir.mkdir(exist_ok=True)
        self.status_dir.mkdir(exist_ok=True)
        
        # Initialize config
        self.config = self.load_config()
        self.sessions = self.load_sessions()
        
        # For live monitoring
        self.log_queue = queue.Queue()
        self.current_status = 'idle'
    
    def load_config(self):
        """Load or create configuration"""
        if self.config_file.exists():
            with open(self.config_file) as f:
                return json.load(f)
        else:
            config = {
                'claude_code_command': 'claude',
                'monitor_interval': 0.5
            }
            with open(self.config_file, 'w') as f:
                json.dump(config, f, indent=2)
            return config
    
    def load_sessions(self):
        """Load existing sessions"""
        if self.sessions_file.exists():
            with open(self.sessions_file) as f:
                return json.load(f)
        return {}
    
    def save_sessions(self):
        """Save sessions to file"""
        with open(self.sessions_file, 'w') as f:
            json.dump(self.sessions, f, indent=2)
    
    def create_hooks_config(self, session_id):
        """Create hooks configuration for Claude Code"""
        hooks_config = {
            "hooks": {
                "PreToolUse": [
                    {
                        "matcher": ".*",
                        "hooks": [
                            {
                                "type": "command",
                                "command": f"python3 {self.hooks_dir}/pre_tool_use.py {session_id}"
                            }
                        ]
                    }
                ],
                "UserPromptSubmit": [
                    {
                        "hooks": [
                            {
                                "type": "command",
                                "command": f"python3 {self.hooks_dir}/user_prompt_submit.py {session_id}"
                            }
                        ]
                    }
                ],
                "Stop": [
                    {
                        "hooks": [
                            {
                                "type": "command",
                                "command": f"python3 {self.hooks_dir}/stop_hook.py {session_id}"
                            }
                        ]
                    }
                ]
            }
        }
        
        # Create Claude settings directory if it doesn't exist
        claude_dir = Path.home() / '.claude'
        claude_dir.mkdir(exist_ok=True)
        
        # Save current settings if they exist
        settings_file = claude_dir / 'settings.json'
        backup_file = claude_dir / 'settings.json.backup'
        
        if settings_file.exists():
            with open(settings_file) as f:
                existing_settings = json.load(f)
            with open(backup_file, 'w') as f:
                json.dump(existing_settings, f, indent=2)
        
        # Write our hooks configuration
        with open(settings_file, 'w') as f:
            json.dump(hooks_config, f, indent=2)
        
        return settings_file, backup_file if backup_file.exists() else None
    
    def restore_settings(self, backup_file):
        """Restore original Claude settings"""
        if backup_file and backup_file.exists():
            settings_file = Path.home() / '.claude' / 'settings.json'
            with open(backup_file) as f:
                settings = json.load(f)
            with open(settings_file, 'w') as f:
                json.dump(settings, f, indent=2)
            backup_file.unlink()
    
    def log_event(self, session_id, event_type, message, display=True):
        """Log an event for a session"""
        timestamp = datetime.now()
        log_entry = {
            'timestamp': timestamp.isoformat(),
            'type': event_type,
            'message': message
        }
        
        # Write to log file
        log_file = self.logs_dir / f'{session_id}.log'
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
        
        # Add to queue for live display if display is True
        if display:
            self.log_queue.put((timestamp, event_type, message))
    
    def get_latest_prompt(self, session_id):
        """Get the latest user prompt for display"""
        prompt_log_file = self.logs_dir / f'{session_id}_prompts.log'
        if prompt_log_file.exists():
            try:
                with open(prompt_log_file, 'r') as f:
                    lines = f.readlines()
                    if lines:
                        last_entry = json.loads(lines[-1])
                        return last_entry.get('prompt', '')
            except:
                pass
        return None
    
    def monitor_status(self, session_id):
        """Monitor status file for changes"""
        last_status = None
        last_update = None
        status_file = self.status_dir / f'{session_id}.json'
        
        while True:
            try:
                if status_file.exists():
                    with open(status_file) as f:
                        session_status = json.load(f)
                        current_state = session_status.get('state', 'idle')
                        current_tool = session_status.get('last_tool', '')
                        current_action = session_status.get('current_action', '')
                        timestamp = session_status.get('timestamp', '')
                        
                        # Check if status changed
                        if current_state != last_status or timestamp != last_update:
                            last_status = current_state
                            last_update = timestamp
                            self.current_status = current_state
                            
                            # Log the status change with meaningful messages
                            if current_state == 'working':
                                # Extract tool name from action if available
                                tool_info = current_action.replace('Using ', '')
                                self.log_event(session_id, 'TOOL', f'Using {tool_info}')
                            elif current_state == 'idle':
                                # Only show idle from Stop hook (Response complete)
                                if 'Response complete' in current_action:
                                    self.log_event(session_id, 'STATUS', 'Idle')
                            elif current_state == 'processing':
                                # Get and display the user prompt
                                latest_prompt = self.get_latest_prompt(session_id)
                                if latest_prompt and latest_prompt.strip() != 'continue':
                                    # Only show non-continue prompts (continue is shown by auto-continue)
                                    # Truncate long prompts for display
                                    display_prompt = latest_prompt[:100] + '...' if len(latest_prompt) > 100 else latest_prompt
                                    # Remove newlines for cleaner display
                                    display_prompt = display_prompt.replace('\n', ' ')
                                    self.log_event(session_id, 'USER', f'"{display_prompt}"')
                                self.log_event(session_id, 'STATUS', 'Processing')
                
                time.sleep(0.2)  # Check status frequently
                
            except Exception as e:
                # Don't log errors for missing status file
                pass
    
    def monitor_process(self, session_id, pid):
        """Monitor Claude process - improved with less aggressive ending detection"""
        self.log_event(session_id, 'DEBUG', f'Starting to monitor process {pid}', display=False)
        consecutive_failures = 0
        max_failures = 3  # Allow 3 consecutive failures before declaring ended
        
        while True:
            try:
                # Check if process is still running
                result = subprocess.run(['ps', '-p', str(pid)], capture_output=True, text=True)
                
                if result.returncode != 0:
                    consecutive_failures += 1
                    self.log_event(session_id, 'DEBUG', f'Process check failed, count: {consecutive_failures}/{max_failures}', display=False)
                    
                    if consecutive_failures >= max_failures:
                        # Triple-check with different methods before declaring it ended
                        verify_methods = [
                            ['ps', 'aux'],
                            ['pgrep', '-f', 'claude'],
                        ]
                        
                        claude_still_running = False
                        for method in verify_methods:
                            try:
                                verify_result = subprocess.run(method, capture_output=True, text=True)
                                if verify_result.returncode == 0:
                                    for line in verify_result.stdout.split('\n'):
                                        if str(pid) in line and 'claude' in line:
                                            claude_still_running = True
                                            break
                                    if claude_still_running:
                                        break
                            except Exception:
                                continue
                        
                        if not claude_still_running:
                            self.log_event(session_id, 'SESSION_END', f'Claude session ended (PID {pid} confirmed dead after {consecutive_failures} checks)')
                            self.sessions[session_id]['status'] = 'ended'
                            self.sessions[session_id]['ended_at'] = datetime.now().isoformat()
                            self.save_sessions()
                            break
                        else:
                            self.log_event(session_id, 'DEBUG', f'False alarm - claude process {pid} still running', display=False)
                            consecutive_failures = 0  # Reset counter
                else:
                    # Process found, reset failure counter
                    consecutive_failures = 0
                
                time.sleep(self.config['monitor_interval'])
                
            except Exception as e:
                self.log_event(session_id, 'ERROR', f'Process monitoring error: {str(e)}')
                break
    
    def is_claude_running(self):
        """Simple check if any Claude process is running"""
        try:
            result = subprocess.run(['pgrep', '-f', self.config['claude_code_command']], 
                                  capture_output=True, text=True)
            return result.returncode == 0 and result.stdout.strip()
        except Exception:
            # Fallback to ps method
            try:
                result = subprocess.run(['ps', 'aux'], capture_output=True, text=True)
                if result.returncode == 0:
                    for line in result.stdout.split('\n'):
                        if self.config['claude_code_command'] in line and 'ccmaster' not in line:
                            return True
            except Exception:
                pass
        return False
    
    def simple_monitor_session(self, session_id):
        """Simple session monitoring that just checks if Claude is still running"""
        consecutive_failures = 0
        max_failures = 5  # Allow 5 consecutive failures (10 seconds) before declaring dead
        
        # Wait a bit for Claude to start
        time.sleep(3)
        
        while True:
            try:
                if self.is_claude_running():
                    consecutive_failures = 0
                    self.log_event(session_id, 'DEBUG', 'Claude process detected', display=False)
                else:
                    consecutive_failures += 1
                    self.log_event(session_id, 'DEBUG', f'Claude not detected, count: {consecutive_failures}/{max_failures}', display=False)
                    
                    if consecutive_failures >= max_failures:
                        print(f"\n[{datetime.now().strftime('%H:%M:%S')}] 💀 Claude session appears to have ended")
                        self.sessions[session_id]['status'] = 'ended'
                        self.sessions[session_id]['ended_at'] = datetime.now().isoformat()
                        self.save_sessions()
                        self.log_event(session_id, 'SESSION_END', 'Claude session ended (process not found)')
                        break
                
                time.sleep(2)  # Check every 2 seconds
                
            except Exception as e:
                self.log_event(session_id, 'ERROR', f'Monitoring error: {str(e)}')
                break
    
    def send_continue_to_claude(self):
        """Send 'continue' to Claude using the simplest possible approach"""
        # Method 1: Find Terminal window running Claude and send continue
        simple_script = '''
        tell application "Terminal"
            activate
            -- Find the window with Claude running
            repeat with w in windows
                repeat with t in tabs of w
                    try
                        if (processes of t) contains "claude" then
                            -- Found Claude tab, make it active and send continue
                            set frontmost of w to true
                            set selected of t to true
                            delay 0.3
                            
                            -- Type continue and press return
                            tell application "System Events"
                                tell process "Terminal"
                                    keystroke "continue"
                                    delay 0.1
                                    keystroke return
                                end tell
                            end tell
                            return "success"
                        end if
                    end try
                end repeat
            end repeat
            return "no_claude_found"
        end tell
        '''
        
        try:
            result = subprocess.run(['osascript', '-e', simple_script], 
                                  capture_output=True, text=True, timeout=10)
            
            if result.returncode == 0:
                output = result.stdout.strip()
                if output == "success":
                    return True
                elif output == "no_claude_found":
                    print(f"[{datetime.now().strftime('%H:%M:%S')}] {Colors.YELLOW}⚠️  No Claude terminal found for auto-continue{Colors.RESET}")
                    return False
            
            # If that fails, try the even simpler approach
            fallback_script = '''
            tell application "System Events"
                -- Just type in whatever Terminal window is frontmost
                keystroke "continue"
                delay 0.1
                keystroke return
            end tell
            '''
            
            result2 = subprocess.run(['osascript', '-e', fallback_script],
                                   capture_output=True, text=True, timeout=5)
            
            if result2.returncode == 0:
                print(f"[{datetime.now().strftime('%H:%M:%S')}] {Colors.BLUE}📝 Sent 'continue' to frontmost terminal{Colors.RESET}")
                return True
                
        except Exception as e:
            print(f"[{datetime.now().strftime('%H:%M:%S')}] {Colors.YELLOW}⚠️  Auto-continue failed: {str(e)}{Colors.RESET}")
        
        print(f"[{datetime.now().strftime('%H:%M:%S')}] 💡 Please type 'continue' manually")
        return False
    
    def format_status_line(self, status):
        """Format status line with color"""
        if status == 'working':
            return f"{Colors.GREEN}● Working{Colors.RESET}"
        elif status == 'idle':
            return f"{Colors.RED}● Idle{Colors.RESET}"
        elif status == 'processing':
            return f"{Colors.YELLOW}● Processing{Colors.RESET}"
        elif status == 'thinking':
            return f"{Colors.BLUE}● Thinking{Colors.RESET}"
        else:
            return f"{Colors.BLUE}● {status.capitalize()}{Colors.RESET}"
    
    def check_keyboard_input(self):
        """Check if a key has been pressed without blocking"""
        if sys.stdin in select.select([sys.stdin], [], [], 0)[0]:
            return sys.stdin.read(1)
        return None
    
    def start_session_and_monitor(self, working_dir=None, watch_mode=False, max_turns=None):
        """Start a new Claude Code session and monitor it"""
        session_id = datetime.now().strftime('%Y%m%d_%H%M%S')
        # Always use current working directory if not specified
        working_dir = working_dir or os.getcwd()
        
        # Create session entry
        self.sessions[session_id] = {
            'id': session_id,
            'started_at': datetime.now().isoformat(),
            'working_dir': working_dir,
            'status': 'starting',
            'last_activity': datetime.now().isoformat()
        }
        self.save_sessions()
        
        print(f"\n🚀 Starting Claude session in {working_dir}")
        print(f"📍 Session ID: {session_id}")
        if watch_mode:
            if max_turns:
                print(f"👁️  {Colors.GREEN}Watch mode: ON - Will auto-continue after idle (max {max_turns} turns){Colors.RESET}")
            else:
                print(f"👁️  {Colors.GREEN}Watch mode: ON - Will auto-continue after idle{Colors.RESET}")
        else:
            print(f"👀 Watch mode: OFF - Press [w] to toggle")
        print()
        
        self.log_event(session_id, 'SESSION_START', f'Starting in {working_dir}', display=False)
        
        # Create per-session hooks configuration
        settings_file, backup_file = self.create_hooks_config(session_id)
        self.log_event(session_id, 'HOOKS', f'Created hooks configuration for session', display=False)
        
        # Prepare Claude Code command
        claude_cmd = self.config['claude_code_command']
        
        # Simple AppleScript to open Terminal and start Claude
        applescript = f'''
        tell application "Terminal"
            activate
            do script "cd {working_dir} && {claude_cmd}"
        end tell
        '''
        
        # Execute AppleScript
        result = subprocess.run(['osascript', '-e', applescript], 
                                capture_output=True, text=True)
        
        if result.returncode == 0:
            print(f"[{datetime.now().strftime('%H:%M:%S')}] 🚀 Launched Claude in Terminal")
            self.log_event(session_id, 'TERMINAL', f'Launched Claude in Terminal', display=False)
        else:
            print(f"[{datetime.now().strftime('%H:%M:%S')}] ❌ Failed to launch Claude: {result.stderr}")
            self.log_event(session_id, 'ERROR', f'Failed to launch Claude: {result.stderr}', display=True)
        
        # Update session status
        self.sessions[session_id]['status'] = 'running'
        self.save_sessions()
        
        # Start simple monitoring thread that checks if Claude is running
        monitor_thread = threading.Thread(
            target=self.simple_monitor_session,
            args=(session_id,),
            daemon=True
        )
        monitor_thread.start()
        
        # Start status monitoring thread
        status_thread = threading.Thread(
            target=self.monitor_status,
            args=(session_id,),
            daemon=True
        )
        status_thread.start()
        
        # Initial status
        current_status_display = self.format_status_line('idle')
        has_seen_first_prompt = False
        auto_continue_pending = False
        continue_countdown = 0
        auto_continue_count = 0  # Track number of auto-continues
        
        # Set up terminal for non-blocking input
        old_settings = termios.tcgetattr(sys.stdin)
        tty.setcbreak(sys.stdin.fileno())
        
        try:
            while True:
                # Check if session is still running
                if session_id in self.sessions and self.sessions[session_id]['status'] == 'ended':
                    print(f"\r\n🛑 Session ended")
                    break
                
                # Check for keyboard input
                key = self.check_keyboard_input()
                if key == 'w':
                    was_at_max_turns = max_turns and auto_continue_count >= max_turns
                    watch_mode = not watch_mode
                    timestamp = datetime.now()
                    time_str = timestamp.strftime('%H:%M:%S')
                    if watch_mode:
                        # Reset auto-continue count when toggling watch mode on after hitting max
                        if was_at_max_turns:
                            auto_continue_count = 0
                            print(f"[{time_str}] {Colors.GREEN}🔄 Auto-continue count reset{Colors.RESET}")
                        
                        if max_turns:
                            remaining = max_turns - auto_continue_count
                            print(f"[{time_str}] {Colors.GREEN}👁️  Watch mode: ON - Will auto-continue after idle ({remaining} turns left){Colors.RESET}")
                        else:
                            print(f"[{time_str}] {Colors.GREEN}👁️  Watch mode: ON - Will auto-continue after idle{Colors.RESET}")
                        
                        # If we're currently idle and re-enabling after max turns, immediately continue
                        if was_at_max_turns and self.current_status == 'idle':
                            # Send continue immediately
                            if self.send_continue_to_claude():
                                auto_continue_count += 1
                                if max_turns:
                                    print(f"[{time_str}] {Colors.GREEN}▶ Auto-continue ({auto_continue_count}/{max_turns}){Colors.RESET}")
                                else:
                                    print(f"[{time_str}] {Colors.GREEN}▶ Auto-continue{Colors.RESET}")
                    else:
                        print(f"[{time_str}] 👀 Watch mode: OFF")
                        # Cancel any pending auto-continue
                        auto_continue_pending = False
                        continue_countdown = 0
                
                # Display queued log messages
                try:
                    while True:
                        timestamp, event_type, message = self.log_queue.get_nowait()
                        
                        time_str = timestamp.strftime('%H:%M:%S')
                        
                        if event_type == 'STATUS':
                            # Format main status updates
                            if 'Processing' in message:
                                status_display = self.format_status_line('processing')
                                print(f"[{time_str}] {status_display}")
                            elif 'Thinking' in message:
                                status_display = self.format_status_line('thinking')
                                print(f"[{time_str}] {status_display}")
                            elif 'Idle' in message:
                                status_display = self.format_status_line('idle')
                                print(f"[{time_str}] {status_display}")
                                # In watch mode, auto-continue after first prompt
                                if watch_mode and has_seen_first_prompt:
                                    # Check if we've reached max turns
                                    if max_turns is None or auto_continue_count < max_turns:
                                        auto_continue_pending = True
                                        continue_countdown = 2  # 2 seconds to ensure Claude is really idle
                                    else:
                                        print(f"[{time_str}] {Colors.YELLOW}🛑 Max auto-continue turns ({max_turns}) reached - Watch mode disabled{Colors.RESET}")
                                        print(f"[{time_str}] 💡 Press [w] to re-enable and continue")
                                        watch_mode = False
                            current_status_display = status_display
                            
                        elif event_type == 'USER':
                            # Format user prompt
                            print(f"[{time_str}] {Colors.BLUE}▶{Colors.RESET} User: {message}")
                            has_seen_first_prompt = True
                            
                        elif event_type == 'TOOL':
                            # Format tool activity updates
                            if 'Using' in message:
                                tool_name = message.replace('Using ', '')
                                print(f"[{time_str}] {Colors.GREEN}→{Colors.RESET} {message}")
                            elif 'Completed' in message:
                                tool_name = message.replace('Completed ', '')
                                print(f"[{time_str}] {Colors.BLUE}✓{Colors.RESET} {message}")
                                
                        elif event_type == 'SESSION_END':
                            print(f"\n[{time_str}] 🛑 {message}")
                        
                except queue.Empty:
                    pass
                
                # Handle auto-continue in watch mode
                if watch_mode and auto_continue_pending and continue_countdown > 0:
                    time.sleep(1)  # Count down 1 second
                    continue_countdown -= 1
                    
                    if continue_countdown == 0:
                        # Send continue command
                        if self.send_continue_to_claude():
                            auto_continue_pending = False
                            auto_continue_count += 1
                            # Log the successful auto-continue
                            timestamp = datetime.now()
                            time_str = timestamp.strftime('%H:%M:%S')
                            if max_turns:
                                print(f"[{time_str}] {Colors.GREEN}▶ Auto-continue ({auto_continue_count}/{max_turns}){Colors.RESET}")
                            else:
                                print(f"[{time_str}] {Colors.GREEN}▶ Auto-continue{Colors.RESET}")
                        else:
                            # Auto-continue failed, cancel it
                            auto_continue_pending = False
                else:
                    time.sleep(0.1)
                
        except KeyboardInterrupt:
            print(f"\n\n✋ Stopped monitoring (Claude continues running)")
            print(f"📝 View full logs: ccmaster logs {session_id}")
        finally:
            # Restore terminal settings
            termios.tcsetattr(sys.stdin, termios.TCSADRAIN, old_settings)
            # Restore original settings if we have a backup
            if 'backup_file' in locals() and backup_file:
                self.restore_settings(backup_file)
    
    def list_sessions(self):
        """List all sessions"""
        if not self.sessions:
            print("No sessions found")
            return
        
        print("Claude Code Sessions:")
        print("-" * 80)
        for session_id, session in self.sessions.items():
            status_icon = "🟢" if session['status'] == 'running' else "⚫"
            print(f"{status_icon} Session: {session_id}")
            print(f"   Started: {session['started_at']}")
            print(f"   Status: {session['status']}")
            print(f"   Directory: {session['working_dir']}")
            if 'pid' in session:
                print(f"   PID: {session['pid']}")
            if 'ended_at' in session:
                print(f"   Ended: {session['ended_at']}")
            print()
    
    def view_logs(self, session_id):
        """View logs for a specific session"""
        log_file = self.logs_dir / f'{session_id}.log'
        if not log_file.exists():
            print(f"No logs found for session {session_id}")
            return
        
        print(f"Logs for session {session_id}:")
        print("-" * 60)
        
        with open(log_file) as f:
            for line in f:
                entry = json.loads(line)
                timestamp = datetime.fromisoformat(entry['timestamp'])
                print(f"[{timestamp.strftime('%H:%M:%S')}] {entry['type']}: {entry['message']}")
    
    def view_prompts(self, session_id):
        """View all user prompts for a specific session"""
        prompt_file = self.logs_dir / f'{session_id}_prompts.log'
        if not prompt_file.exists():
            print(f"No prompts found for session {session_id}")
            return
        
        print(f"User prompts for session {session_id}:")
        print("-" * 60)
        
        with open(prompt_file) as f:
            for i, line in enumerate(f, 1):
                entry = json.loads(line)
                timestamp = datetime.fromisoformat(entry['timestamp'])
                prompt = entry['prompt']
                print(f"\n[{i}] {timestamp.strftime('%Y-%m-%d %H:%M:%S')}")
                print(f"Prompt: {prompt}")
                print("-" * 60)

def main():
    parser = argparse.ArgumentParser(description='CCMaster - Claude Code Session Manager')
    subparsers = parser.add_subparsers(dest='command', help='Commands')
    
    # Start command (default)
    start_parser = subparsers.add_parser('start', help='Start and monitor a new Claude session')
    start_parser.add_argument('-d', '--dir', help='Working directory', default=None)
    
    # Watch command
    watch_parser = subparsers.add_parser('watch', help='Start in watch mode (auto-continue)')
    watch_parser.add_argument('-d', '--dir', help='Working directory', default=None)
    watch_parser.add_argument('--maxturn', type=int, help='Maximum number of auto-continue turns', default=None)
    
    # List command
    subparsers.add_parser('list', help='List all sessions')
    
    # Logs command
    logs_parser = subparsers.add_parser('logs', help='View session logs')
    logs_parser.add_argument('session', help='Session ID')
    
    # Prompts command
    prompts_parser = subparsers.add_parser('prompts', help='View user prompts for a session')
    prompts_parser.add_argument('session', help='Session ID')
    
    args = parser.parse_args()
    
    cc = CCMaster()
    
    if args.command == 'start' or args.command is None:
        # Default to start if no command given
        working_dir = args.dir if args.command == 'start' else None
        cc.start_session_and_monitor(working_dir, watch_mode=False)
    elif args.command == 'watch':
        cc.start_session_and_monitor(args.dir, watch_mode=True, max_turns=args.maxturn)
    elif args.command == 'list':
        cc.list_sessions()
    elif args.command == 'logs':
        cc.view_logs(args.session)
    elif args.command == 'prompts':
        cc.view_prompts(args.session)
    else:
        parser.print_help()

if __name__ == '__main__':
    main()